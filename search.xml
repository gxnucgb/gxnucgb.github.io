<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>numpy</title>
      <link href="/2019/09/19/numpy%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/"/>
      <url>/2019/09/19/numpy%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="numpy基础数据结构"><a href="#numpy基础数据结构" class="headerlink" title="numpy基础数据结构"></a>numpy基础数据结构</h2><p>numpy数组是一个多维数组对象，称为ndarray。其有两部分组成：</p><ol><li>实际的数据</li><li>描述这些数据的元数据</li></ol><h3 id="多维数据ndarray"><a href="#多维数据ndarray" class="headerlink" title="多维数据ndarray"></a>多维数据ndarray</h3><p>在使用这个属性方法之前，需要先导入numpy包<br><code>import numpy as np</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ar = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(ar)          <span class="comment"># 输出数组，注意数组的格式：中括号，元素之间没有逗号（和列表区分）</span></span><br><span class="line">print(ar.ndim)     <span class="comment"># 输出数组维度的个数（轴数），或者说“秩”，维度的数量也称rank</span></span><br><span class="line">print(ar.shape)    <span class="comment"># 数组的维度，对于n行m列的数组，shape为（n，m）</span></span><br><span class="line">print(ar.size)     <span class="comment"># 数组的元素总数，对于n行m列的数组，元素总数为n*m</span></span><br><span class="line">print(ar.dtype)    <span class="comment"># 数组中元素的类型，类似type()（注意了，type()是函数，.dtype是方法）</span></span><br><span class="line">print(ar.itemsize) <span class="comment"># 数组中每个元素的字节大小，int32l类型字节为4，float64的字节为8</span></span><br><span class="line">print(ar.data)     <span class="comment"># 包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。输出一般会是一个地址如：&lt;memory at 0x0000000005927108&gt;</span></span><br></pre></td></tr></table></figure><h3 id="数组的基本属性"><a href="#数组的基本属性" class="headerlink" title="数组的基本属性"></a>数组的基本属性</h3><p>① 数组的维数称为秩（rank），一维数组的秩为1，二维数组的秩为2，以此类推<br> ② 在NumPy中，每一个线性的数组称为是一个轴（axes），秩其实是描述轴的数量：<br> 比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组所以一维数组就是NumPy中的轴（axes），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。 </p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><h4 id="array-函数"><a href="#array-函数" class="headerlink" title="array()函数"></a>array()函数</h4><p>括号内可以是列表、元组、数组、生成器等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar1 = np.array(range(<span class="number">10</span>))   <span class="comment"># 整型</span></span><br><span class="line">ar2 = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3.14</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment"># 浮点型</span></span><br><span class="line">ar3 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>)])   <span class="comment"># 二维数组：嵌套序列（列表，元祖均可）</span></span><br><span class="line">ar4 = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],(<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>)])   <span class="comment"># 注意嵌套序列数量不一会怎么样</span></span><br></pre></td></tr></table></figure><h4 id="arange-函数"><a href="#arange-函数" class="headerlink" title="arange()函数"></a>arange()函数</h4><p>类似于range()，在给定间隔内返回均匀间隔的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(np.arange(<span class="number">10</span>))    <span class="comment"># 返回0-9，整型</span></span><br><span class="line">print(np.arange(<span class="number">10.0</span>))  <span class="comment"># 返回0.0-9.0，浮点型</span></span><br><span class="line">print(np.arange(<span class="number">5</span>,<span class="number">12</span>))  <span class="comment"># 返回5-11</span></span><br><span class="line">print(np.arange(<span class="number">5.0</span>,<span class="number">12</span>,<span class="number">2</span>))  <span class="comment"># 返回5.0-12.0，步长为2</span></span><br><span class="line">print(np.arange(<span class="number">10000</span>))  <span class="comment"># 如果数组太大而无法打印，NumPy会自动跳过数组的中心部分，并只打印边角</span></span><br></pre></td></tr></table></figure><h4 id="linspace-：num个均匀的样本"><a href="#linspace-：num个均匀的样本" class="headerlink" title="linspace()：num个均匀的样本"></a>linspace()：num个均匀的样本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar1 = np.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>)</span><br><span class="line">ar2 = np.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">ar3 = np.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>, retstep=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>numpy.linspace(start,stop,num=50,endpoint=True,retstep=False, dtype=None)<br>start：起始值，stop：结束值<br>num：生成样本数，默认为50<br>endpoint：如果为真，则停止是最后一个样本。否则，不包括在内。默认值为True。<br>retstep：如果为真，返回（样本，步骤），其中步长是样本之间的间距 → 输出为一个包含2个元素的元祖，第一个元素为array，第二个为步长实际值</p><h4 id="创建数组：zeros-zeros-like-ones-ones-like"><a href="#创建数组：zeros-zeros-like-ones-ones-like" class="headerlink" title="创建数组：zeros()/zeros_like()/ones()/ones_like()"></a>创建数组：zeros()/zeros_like()/ones()/ones_like()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建数组：zeros()/zeros_like()/ones()/ones_like()</span></span><br><span class="line"></span><br><span class="line">ar1 = np.zeros(<span class="number">5</span>)  </span><br><span class="line">ar2 = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype = np.int)</span><br><span class="line"></span><br><span class="line"><span class="comment"># numpy.zeros(shape, dtype=float, order='C'):返回给定形状和类型的新数组，用零填充。</span></span><br><span class="line"><span class="comment"># shape：数组纬度，二维以上需要用()，且输入参数为整数</span></span><br><span class="line"><span class="comment"># dtype：数据类型，默认numpy.float64</span></span><br><span class="line"><span class="comment"># order：是否在存储器中以C或Fortran连续（按行或列方式）存储多维数据。</span></span><br><span class="line"></span><br><span class="line">ar3 = np.array([list(range(<span class="number">5</span>)),list(range(<span class="number">5</span>,<span class="number">10</span>))])</span><br><span class="line">ar4 = np.zeros_like(ar3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 返回具有与给定数组相同的形状和类型的零数组，这里ar4根据ar3的形状和dtype创建一个全0的数组</span></span><br><span class="line"></span><br><span class="line">ar5 = np.ones(<span class="number">9</span>)</span><br><span class="line">ar6 = np.ones((<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">ar7 = np.ones_like(ar3)</span><br><span class="line"></span><br><span class="line"><span class="comment"># ones()/ones_like()和zeros()/zeros_like()一样，只是填充为1</span></span><br></pre></td></tr></table></figure><h4 id="创建数组：eye"><a href="#创建数组：eye" class="headerlink" title="创建数组：eye()"></a>创建数组：eye()</h4><p>创建一个正方的N*N的单位矩阵，对角线值为1，其余为0<br><code>print(np.eye(5))</code></p><h3 id="numpy通用函数"><a href="#numpy通用函数" class="headerlink" title="numpy通用函数"></a>numpy通用函数</h3><h4 id="数组形状：-T-reshape-resize"><a href="#数组形状：-T-reshape-resize" class="headerlink" title="数组形状：.T/.reshape()/.resize()"></a>数组形状：.T/.reshape()/.resize()</h4><p> .T方法：转置，例如原shape为(3,4)/(2,3,4)，转置结果为(4,3)/(4,3,2) → 所以一维数组转置后结果不变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar3 = ar1.reshape(<span class="number">2</span>,<span class="number">5</span>)     <span class="comment"># 用法1：直接将已有数组改变形状</span></span><br><span class="line">ar4 = np.zeros((<span class="number">4</span>,<span class="number">6</span>)).reshape(<span class="number">3</span>,<span class="number">8</span>)   <span class="comment"># 用法2：生成数组后直接改变形状</span></span><br><span class="line">ar5 = np.reshape(np.arange(<span class="number">12</span>),(<span class="number">3</span>,<span class="number">4</span>))   <span class="comment"># 用法3：参数内添加数组，目标形状</span></span><br></pre></td></tr></table></figure><p>numpy.reshape(a, newshape, order=’C’)：为数组提供新形状，而不更改其数据，所以元素数量需要一致！！</p><p>numpy.resize(a, new_shape)：返回具有指定形状的新数组，如有必要可重复填充所需数量的元素。<br><strong>注意了：.T/.reshape()/.resize()都是生成新的数组！！！</strong></p><h4 id="数组的复制"><a href="#数组的复制" class="headerlink" title="数组的复制"></a>数组的复制</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ar1 = np.arange(<span class="number">10</span>)</span><br><span class="line">ar2 = ar1</span><br><span class="line">print(ar2 <span class="keyword">is</span> ar1)</span><br><span class="line">ar1[<span class="number">2</span>] = <span class="number">9</span></span><br><span class="line">print(ar1,ar2)<span class="comment"># 一起改变了</span></span><br><span class="line"><span class="comment"># 回忆python的赋值逻辑：指向内存中生成的一个值 → 这里ar1和ar2指向同一个值，所以ar1改变，ar2一起改变</span></span><br><span class="line"></span><br><span class="line">ar3 = ar1.copy()</span><br><span class="line">print(ar3 <span class="keyword">is</span> ar1)</span><br><span class="line">ar1[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">print(ar1,ar3) <span class="comment"># 只有ar1变了而已</span></span><br><span class="line"><span class="comment"># copy方法生成数组及其数据的完整拷贝</span></span><br><span class="line"><span class="comment"># 再次提醒：.T/.reshape()/.resize()都是生成新的数组！！！</span></span><br></pre></td></tr></table></figure><h4 id="数组类型转换：-astype"><a href="#数组类型转换：-astype" class="headerlink" title="数组类型转换：.astype()"></a>数组类型转换：.astype()</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ar1 = np.arange(<span class="number">10</span>,dtype=float)</span><br><span class="line">print(ar1,ar1.dtype)</span><br><span class="line">print(<span class="string">'-----'</span>)</span><br><span class="line"><span class="comment"># 可以在参数位置设置数组类型</span></span><br><span class="line"></span><br><span class="line">ar2 = ar1.astype(np.int32)</span><br><span class="line">print(ar2,ar2.dtype)</span><br><span class="line">print(ar1,ar1.dtype)</span><br><span class="line"><span class="comment"># a.astype()：转换数组类型</span></span><br><span class="line"><span class="comment"># 注意：养成好习惯，数组类型用np.int32，而不是直接int32</span></span><br></pre></td></tr></table></figure><h4 id="数组堆叠"><a href="#数组堆叠" class="headerlink" title="数组堆叠"></a>数组堆叠</h4><p>numpy.hstack(tup)：水平（按列顺序）堆叠数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)    <span class="comment"># a为一维数组，5个元素</span></span><br><span class="line">b = np.arange(<span class="number">5</span>,<span class="number">9</span>) <span class="comment"># b为一维数组,4个元素</span></span><br><span class="line">ar1 = np.hstack((a,b))  <span class="comment"># 注意:((a,b))，这里形状可以不一样</span></span><br><span class="line">print(a,a.shape)</span><br><span class="line">print(b,b.shape)</span><br><span class="line">print(ar1,ar1.shape)</span><br><span class="line">a = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])   <span class="comment"># a为二维数组，3行1列</span></span><br><span class="line">b = np.array([[<span class="string">'a'</span>],[<span class="string">'b'</span>],[<span class="string">'c'</span>]])  <span class="comment"># b为二维数组，3行1列</span></span><br><span class="line">ar2 = np.hstack((a,b))  <span class="comment"># 注意:((a,b))，这里形状必须一样</span></span><br><span class="line">print(a,a.shape)</span><br><span class="line">print(b,b.shape)</span><br><span class="line">print(ar2,ar2.shape)</span><br></pre></td></tr></table></figure><p>numpy.vstack(tup)：垂直（按列顺序）堆叠数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)    </span><br><span class="line">b = np.arange(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">ar1 = np.vstack((a,b))</span><br><span class="line">print(a,a.shape)</span><br><span class="line">print(b,b.shape)</span><br><span class="line">print(ar1,ar1.shape)</span><br><span class="line">a = np.array([[<span class="number">1</span>],[<span class="number">2</span>],[<span class="number">3</span>]])   </span><br><span class="line">b = np.array([[<span class="string">'a'</span>],[<span class="string">'b'</span>],[<span class="string">'c'</span>],[<span class="string">'d'</span>]])   </span><br><span class="line">ar2 = np.vstack((a,b))  <span class="comment"># 这里形状可以不一样</span></span><br><span class="line">print(a,a.shape)</span><br><span class="line">print(b,b.shape)</span><br><span class="line">print(ar2,ar2.shape)</span><br></pre></td></tr></table></figure><p>numpy.stack(arrays, axis=0)：沿着新轴连接数组的序列，形状必须一样！<br>重点解释axis参数的意思，假设两个数组[1 2 3]和[4 5 6]，shape均为(3,0)<br>axis=0：[[1 2 3] [4 5 6]]，shape为(2,3)<br>axis=1：[[1 4] [2 5] [3 6]]，shape为(3,2)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">5</span>)    </span><br><span class="line">b = np.arange(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line">ar1 = np.stack((a,b))</span><br><span class="line">ar2 = np.stack((a,b),axis = <span class="number">1</span>)</span><br><span class="line">print(a,a.shape)</span><br><span class="line">print(b,b.shape)</span><br><span class="line">print(ar1,ar1.shape)</span><br><span class="line">print(ar2,ar2.shape)</span><br></pre></td></tr></table></figure><h4 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h4><p>numpy.hsplit(ary, indices_or_sections)：将数组水平（逐列）拆分为多个子数组 → 按列拆分<br>输出结果为列表，列表中元素为数组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">ar1 = np.hsplit(ar,<span class="number">2</span>)</span><br><span class="line">print(ar)</span><br><span class="line">print(ar1,type(ar1))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>]</span><br><span class="line"> [ <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>]</span><br><span class="line"> [ <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"> [<span class="number">12</span> <span class="number">13</span> <span class="number">14</span> <span class="number">15</span>]]</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">13</span>]]), array([[ <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [<span class="number">14</span>, <span class="number">15</span>]])]</span><br></pre></td></tr></table></figure><p>numpy.vsplit(ary, indices_or_sections)：:将数组垂直（行方向）拆分为多个子数组 → 按行拆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ar2 = np.vsplit(ar,<span class="number">4</span>)</span><br><span class="line">print(ar2,type(ar2))</span><br></pre></td></tr></table></figure><h4 id="数组简单运算"><a href="#数组简单运算" class="headerlink" title="数组简单运算"></a>数组简单运算</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(ar + <span class="number">10</span>)   <span class="comment"># 加法</span></span><br><span class="line">print(ar * <span class="number">2</span>)   <span class="comment"># 乘法</span></span><br><span class="line">print(<span class="number">1</span> / (ar+<span class="number">1</span>))  <span class="comment"># 除法</span></span><br><span class="line">print(ar ** <span class="number">0.5</span>)  <span class="comment"># 幂</span></span><br><span class="line"><span class="comment"># 与标量的运算</span></span><br><span class="line"></span><br><span class="line">print(ar.mean())  <span class="comment"># 求平均值</span></span><br><span class="line">print(ar.max())  <span class="comment"># 求最大值</span></span><br><span class="line">print(ar.min())  <span class="comment"># 求最小值</span></span><br><span class="line">print(ar.std())  <span class="comment"># 求标准差</span></span><br><span class="line">print(ar.var())  <span class="comment"># 求方差</span></span><br><span class="line">print(ar.sum(), np.sum(ar,axis = <span class="number">0</span>))  <span class="comment"># 求和，np.sum() → axis为0，按列求和；axis为1，按行求和</span></span><br><span class="line">print(np.sort(np.array([<span class="number">1</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])))  <span class="comment"># 排序</span></span><br></pre></td></tr></table></figure><h3 id="numpy索引及切片"><a href="#numpy索引及切片" class="headerlink" title="numpy索引及切片"></a>numpy索引及切片</h3><p>核心：基本索引及切片、布尔型索引及切片</p><h4 id="基本索引及切片"><a href="#基本索引及切片" class="headerlink" title="基本索引及切片"></a>基本索引及切片</h4><h5 id="一维数组索引及切片"><a href="#一维数组索引及切片" class="headerlink" title="一维数组索引及切片"></a>一维数组索引及切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">20</span>)</span><br><span class="line">print(ar)</span><br><span class="line">print(ar[<span class="number">4</span>])</span><br><span class="line">print(ar[<span class="number">3</span>:<span class="number">6</span>])</span><br></pre></td></tr></table></figure><h5 id="二维数组及切片"><a href="#二维数组及切片" class="headerlink" title="二维数组及切片"></a>二维数组及切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">16</span>).reshape(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">print(ar, <span class="string">'数组轴数为%i'</span> %ar.ndim)   <span class="comment"># 4*4的数组</span></span><br><span class="line">print(ar[<span class="number">2</span>],  <span class="string">'数组轴数为%i'</span> %ar[<span class="number">2</span>].ndim)  <span class="comment"># 切片为下一维度的一个元素，所以是一维数组</span></span><br><span class="line">print(ar[<span class="number">2</span>][<span class="number">1</span>]) <span class="comment"># 二次索引，得到一维数组中的一个值</span></span><br><span class="line">print(ar[<span class="number">1</span>:<span class="number">3</span>],  <span class="string">'数组轴数为%i'</span> %ar[<span class="number">1</span>:<span class="number">3</span>].ndim)  <span class="comment"># 切片为两个一维数组组成的二维数组</span></span><br><span class="line">print(ar[<span class="number">2</span>,<span class="number">2</span>])  <span class="comment"># 切片数组中的第三行第三列 → 10</span></span><br><span class="line">print(ar[:<span class="number">2</span>,<span class="number">1</span>:])  <span class="comment"># 切片数组中的1,2行、2,3,4列 → 二维数组</span></span><br></pre></td></tr></table></figure><h5 id="三维数组及切片"><a href="#三维数组及切片" class="headerlink" title="三维数组及切片"></a>三维数组及切片</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">8</span>).reshape(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">print(ar, <span class="string">'数组轴数为%i'</span> %ar.ndim)   <span class="comment"># 2*2*2的数组</span></span><br><span class="line">print(ar[<span class="number">0</span>],  <span class="string">'数组轴数为%i'</span> %ar[<span class="number">0</span>].ndim)  <span class="comment"># 三维数组的下一个维度的第一个元素 → 一个二维数组</span></span><br><span class="line">print(ar[<span class="number">0</span>][<span class="number">0</span>],  <span class="string">'数组轴数为%i'</span> %ar[<span class="number">0</span>][<span class="number">0</span>].ndim)  <span class="comment"># 三维数组的下一个维度的第一个元素下的第一个元素 → 一个一维数组</span></span><br><span class="line">print(ar[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>],  <span class="string">'数组轴数为%i'</span> %ar[<span class="number">0</span>][<span class="number">0</span>][<span class="number">1</span>].ndim)</span><br></pre></td></tr></table></figure><h3 id="布尔型索引及切片"><a href="#布尔型索引及切片" class="headerlink" title="布尔型索引及切片"></a>布尔型索引及切片</h3><p>布尔型索引：以布尔型的矩阵去做筛选</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">i = np.array([<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">True</span>])</span><br><span class="line">j = np.array([<span class="literal">True</span>,<span class="literal">True</span>,<span class="literal">False</span>,<span class="literal">False</span>])</span><br><span class="line">print(ar)</span><br><span class="line">print(i)</span><br><span class="line">print(j)</span><br><span class="line">print(ar[i,:])  <span class="comment"># 在第一维度做判断，只保留True，这里第一维度就是行，ar[i,:] = ar[i]（简单书写格式）</span></span><br><span class="line">print(ar[:,j])  <span class="comment"># 在第二维度做判断，这里如果ar[:,i]会有警告，因为i是3个元素，而ar在列上有4个</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m = ar &gt; <span class="number">5</span></span><br><span class="line">print(m)  <span class="comment"># 这里m是一个判断矩阵</span></span><br><span class="line">print(ar[m])  <span class="comment"># 用m判断矩阵去筛选ar数组中&gt;5的元素 → 重点！后面的pandas判断方式原理就来自此处</span></span><br></pre></td></tr></table></figure><p>数组索引及切片的值更改、复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">10</span>)</span><br><span class="line">print(ar)</span><br><span class="line">ar[<span class="number">5</span>] = <span class="number">100</span></span><br><span class="line">ar[<span class="number">7</span>:<span class="number">9</span>] = <span class="number">200</span></span><br><span class="line">print(ar)</span><br><span class="line"><span class="comment"># 一个标量赋值给一个索引/切片时，会自动改变/传播原始数组</span></span><br></pre></td></tr></table></figure><p>复制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ar = np.arange(<span class="number">10</span>)</span><br><span class="line">b = ar.copy()</span><br><span class="line">b[<span class="number">7</span>:<span class="number">9</span>] = <span class="number">200</span></span><br><span class="line">print(ar)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="numpy随机数"><a href="#numpy随机数" class="headerlink" title="numpy随机数"></a>numpy随机数</h3><p>numpy.random包含多种概率分布的随机样本，是数据分析辅助的重点工具之一</p><p>随机数生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">samples = np.random.normal(size=(<span class="number">4</span>,<span class="number">4</span>))</span><br><span class="line">print(samples)</span><br><span class="line"><span class="comment"># 生成一个标准正太分布的4*4样本值</span></span><br></pre></td></tr></table></figure><p>numpy.random.rand(d0, d1, …, dn)：生成一个[0,1)之间的随机浮点数或N维浮点数组 —— 均匀分布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = np.random.rand()</span><br><span class="line">print(a,type(a))  <span class="comment"># 生成一个随机浮点数</span></span><br><span class="line"></span><br><span class="line">b = np.random.rand(<span class="number">4</span>)</span><br><span class="line">print(b,type(b))  <span class="comment"># 生成形状为4的一维数组</span></span><br><span class="line"></span><br><span class="line">c = np.random.rand(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">print(c,type(c))  <span class="comment"># 生成形状为2*3的二维数组，注意这里不是((2,3))</span></span><br><span class="line"><span class="comment"># 生成1000个均匀分布的样本值</span></span><br><span class="line">samples1 = np.random.rand(<span class="number">1000</span>)</span><br><span class="line">samples2 = np.random.rand(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p>numpy.random.randint(low, high=None, size=None, dtype=’l’)：生成一个整数或N维整数数组<br>若high不为None时，取[low,high)之间随机整数，否则取值[0,low)之间随机整数，且high必须大于low<br>dtype参数：只能是int类型 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(np.random.randint(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># low=2：生成1个[0,2)之间随机整数  </span></span><br><span class="line"></span><br><span class="line">print(np.random.randint(<span class="number">2</span>,size=<span class="number">5</span>))</span><br><span class="line"><span class="comment"># low=2,size=5 ：生成5个[0,2)之间随机整数</span></span><br><span class="line"></span><br><span class="line">print(np.random.randint(<span class="number">2</span>,<span class="number">6</span>,size=<span class="number">5</span>))</span><br><span class="line"><span class="comment"># low=2,high=6,size=5：生成5个[2,6)之间随机整数  </span></span><br><span class="line"></span><br><span class="line">print(np.random.randint(<span class="number">2</span>,size=(<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="comment"># low=2,size=(2,3)：生成一个2x3整数数组,取数范围：[0,2)随机整数 </span></span><br><span class="line"></span><br><span class="line">print(np.random.randint(<span class="number">2</span>,<span class="number">6</span>,(<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="comment"># low=2,high=6,size=(2,3)：生成一个2*3整数数组,取值范围：[2,6)随机整数</span></span><br></pre></td></tr></table></figure><h4 id="存储数组数据-npy文件"><a href="#存储数组数据-npy文件" class="headerlink" title="存储数组数据.npy文件"></a>存储数组数据.npy文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">'C:/Users/Hjx/Desktop/'</span>) <span class="comment"># 路径</span></span><br><span class="line"></span><br><span class="line">ar = np.random.rand(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">print(ar)</span><br><span class="line">np.save(<span class="string">'arraydata.npy'</span>, ar)</span><br><span class="line"><span class="comment"># 也可以直接 np.save('C:/Users/Hjx/Desktop/arraydata.npy', ar)</span></span><br></pre></td></tr></table></figure><p>读取.npy文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ar_load =np.load(<span class="string">'arraydata.npy'</span>)</span><br><span class="line">print(ar_load)</span><br><span class="line"><span class="comment"># 也可以直接 np.load('C:/Users/Hjx/Desktop/arraydata.npy')</span></span><br></pre></td></tr></table></figure><p>存储、读取文本文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ar = np.random.rand(<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">np.savetxt(<span class="string">'array.txt'</span>,ar, delimiter=<span class="string">','</span>)</span><br><span class="line"><span class="comment"># np.savetxt(fname, X, fmt='%.18e', delimiter=' ', newline='\n', header='', footer='', comments='# ')：存储为文本txt文件</span></span><br><span class="line"></span><br><span class="line">ar_loadtxt = np.loadtxt(<span class="string">'array.txt'</span>, delimiter=<span class="string">','</span>)</span><br><span class="line">print(ar_loadtxt)</span><br><span class="line"><span class="comment"># 也可以直接 np.loadtxt('C:/Users/Hjx/Desktop/array.txt')</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>53.类对象，实例对象，类方法，实例方法，类属性，实例属性，静态方法</title>
      <link href="/2019/08/21/53-%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/21/53-%E7%B1%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%EF%BC%8C%E7%B1%BB%E6%96%B9%E6%B3%95%EF%BC%8C%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%8C%E7%B1%BB%E5%B1%9E%E6%80%A7%EF%BC%8C%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%EF%BC%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="类属性、实例属性"><a href="#类属性、实例属性" class="headerlink" title="类属性、实例属性"></a>类属性、实例属性</h4><p>它们在定义和使用中有所区别，而最本质的区别是内存中保存的位置不同</p><ol><li>实例属性属于对象</li><li>类属性属于类</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>52.深拷贝浅拷贝</title>
      <link href="/2019/08/20/52-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/08/20/52-%E6%B7%B1%E6%8B%B7%E8%B4%9D%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<p>可变类型：列表[]，字典{}<br>不可变类型：数字，元组()，字符串</p><ul><li>copy只是拷贝表层的出来（新生成的空间任然指向原来的数据），id与原来不一样了，但是修改原来的数据，新拷贝出来的仍然会变，如果拷贝之后再变，打印出来的东西还是原来拷贝的。</li></ul><p><strong>注意：</strong>copy.copy()拷贝的是元组，那么他不会进行浅拷贝，仅仅是指向，原因：因为元组是不可变类型，那么以为着数据一定不能修改，因此用copy.copy()的时候它会自动判断，如果是元组它就就是指向了它</p><ul><li>deepcopy是拷贝出另外一份数据存着（新生成的空间直接把数据复制过来了，不指向原来的数据），id与原来不一样，但是修改原来的数据与新拷贝出来的无关（如果是不可变数据，例如元组，那么拷出来id还是一样，但是不可变数据里面有可变数据，那么拷出来的id会变）</li></ul><ol><li>如果用 copy.copy、copy.deepcopy 对一个全部都是不可变类型的数据进行拷贝，那么他们的结果相同，都是引用指向</li><li>如果拷贝的是一个拥有不可变类型的数据，即使元组是最顶层，那么deepcopy依然是深拷贝，而copy.copy还是指向</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2019/08/17/%E6%A0%91/"/>
      <url>/2019/08/17/%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h4 id="二叉树的结点表示以及树的创建"><a href="#二叉树的结点表示以及树的创建" class="headerlink" title="二叉树的结点表示以及树的创建"></a>二叉树的结点表示以及树的创建</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""节点类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem=<span class="number">-1</span>, lchild=None, rchild=None)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.lchild = lchild</span><br><span class="line">        self.rchild = rchild</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tree</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""树类"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, root=None)</span>:</span></span><br><span class="line">        self.root = root</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        <span class="string">"""为树添加节点"""</span></span><br><span class="line">        node = Node(elem)</span><br><span class="line">        <span class="comment"># 如果树是空的，则对根节点赋值</span></span><br><span class="line">        <span class="keyword">if</span> self.root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.root = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 用来存</span></span><br><span class="line">            queue = []</span><br><span class="line">            queue.append(self.root)</span><br><span class="line">            <span class="comment"># 对已有的节点进行层次遍历</span></span><br><span class="line">            <span class="keyword">while</span> queue:</span><br><span class="line">                <span class="comment"># 弹出队列的第一个元素</span></span><br><span class="line">                cur = queue.pop(<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">if</span> cur.lchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    cur.lchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">elif</span> cur.rchild <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    cur.rchild = node</span><br><span class="line">                    <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 如果左右子树都不为空，加入队列继续判断</span></span><br><span class="line">                    queue.append(cur.lchild)</span><br><span class="line">                    queue.append(cur.rchild)</span><br></pre></td></tr></table></figure><h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次，我们把这种对所有节点的访问称为遍历（traversal）。那么树的两种重要的遍历模式是深度优先遍历和广度优先遍历,深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现。</p><h4 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h4><p>对于一颗二叉树，深度优先搜索(Depth First Search)是沿着树的深度遍历树的节点，尽可能深的搜索树的分支。<br>那么深度遍历有重要的三种方法。这三种方式常被用于访问树的节点，它们之间的不同在于访问每个节点的次序不同。这三种遍历分别叫做先序遍历（preorder），中序遍历（inorder）和后序遍历（postorder）。我们来给出它们的详细定义，然后举例看看它们的应用。</p><h5 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h5><p>在先序遍历中，我们先访问根节点，然后递归使用先序遍历访问左子树，再递归使用先序遍历访问右子树<br>根节点-&gt;左子树-&gt;右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">preorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">      <span class="string">"""递归实现先序遍历"""</span></span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">print</span> root.elem</span><br><span class="line">      self.preorder(root.lchild)</span><br><span class="line">      self.preorder(root.rchild)</span><br></pre></td></tr></table></figure><h5 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h5><p>在中序遍历中，我们递归使用中序遍历访问左子树，然后访问根节点，最后再递归使用中序遍历访问右子树<br>左子树-&gt;根节点-&gt;右子树</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">      <span class="string">"""递归实现中序遍历"""</span></span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      self.inorder(root.lchild)</span><br><span class="line">      <span class="keyword">print</span> root.elem</span><br><span class="line">      self.inorder(root.rchild)</span><br></pre></td></tr></table></figure><h5 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h5><p>在后序遍历中，我们先递归使用后序遍历访问左子树和右子树，最后访问根节点<br>左子树-&gt;右子树-&gt;根节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">postorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">      <span class="string">"""递归实现后续遍历"""</span></span><br><span class="line">      <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">      self.postorder(root.lchild)</span><br><span class="line">      self.postorder(root.rchild)</span><br><span class="line">      <span class="keyword">print</span> root.elem</span><br></pre></td></tr></table></figure><h4 id="广度优先遍历-层次遍历"><a href="#广度优先遍历-层次遍历" class="headerlink" title="广度优先遍历(层次遍历)"></a>广度优先遍历(层次遍历)</h4><p>从树的root开始，从上到下从从左到右遍历整个树的节点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">breadth_travel</span><span class="params">(self, root)</span>:</span></span><br><span class="line">        <span class="string">"""利用队列实现树的层次遍历"""</span></span><br><span class="line">        <span class="keyword">if</span> root == <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        queue = []</span><br><span class="line">        queue.append(root)</span><br><span class="line">        <span class="keyword">while</span> queue:</span><br><span class="line">            node = queue.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">print</span> node.elem,</span><br><span class="line">            <span class="keyword">if</span> node.lchild != <span class="literal">None</span>:</span><br><span class="line">                queue.append(node.lchild)</span><br><span class="line">            <span class="keyword">if</span> node.rchild != <span class="literal">None</span>:</span><br><span class="line">                queue.append(node.rchild)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="/2019/08/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>/2019/08/17/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>二分查找又称折半查找，有点事比较次数少，查找速度快，平均性能好；其缺点是要求待查表尾有序表，且插入删除困难。因此，折半查找哦方法适用于不经常变动而查找频繁的有序列表。</p><p>首先，假设表中是按升序排列，将表中 间位置的关键字与查找关键字比较，如果两者相等，则查找成功；否则利用中间位置记录将表非常前后两个字表，如果中间位置记录的关键字大于查找关键字，则进一步查找前一子表，否则进一步查找后一字表。重复以上过程，知道找到满足条件的记录，使查找成功，或知道字表不存在为止，此时查找不成功。<br>时间复杂度<br>最坏时间复杂度：O(1)<br>最优时间复杂度：O(lon2n)</p><h4 id="二分查找实现"><a href="#二分查找实现" class="headerlink" title="二分查找实现"></a>二分查找实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(alist, item)</span>:</span></span><br><span class="line">    <span class="string">"""二分查找"""</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">if</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        mid = n//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[mid] == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> item &lt; alist[mid]:</span><br><span class="line">            <span class="keyword">return</span> binary_search(alist[:mid], item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> binary_search(alist[mid+<span class="number">1</span>:], item)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search2</span><span class="params">(alist, item)</span>:</span></span><br><span class="line">    <span class="string">"""二分查找"""</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    first = <span class="number">0</span></span><br><span class="line">    last = n<span class="number">-1</span></span><br><span class="line">    <span class="keyword">while</span> first &lt;= last:</span><br><span class="line">        mid = (first + last)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> alist[mid] == item:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">elif</span> item &lt; alist[mid]:</span><br><span class="line">            last = mid<span class="number">-1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            first = mid + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"没有"</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">22</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">33</span>, <span class="number">55</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    print(binary_search2(li, <span class="number">66</span>))</span><br><span class="line">    print(binary_search2(li, <span class="number">3000</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>快速排序</title>
      <link href="/2019/08/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/16/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序，通过一趟排序将要拍学的数据分割成独立的两部分，其中一部分的的所有数据都比另一部分的所有数据要小，然后再按此方法对这两部分数据进行快速排序，整个排序过程可以递归进行，以达到整个数据变成有序序列。<br>步骤为：</p><ol><li>从数列中挑出一个元素，称为“基准”</li><li>重新排序数列，所有元素比基准值晓得排放在基准前面，所有元素比基准值大的摆放在后面（相同的数可以到任一边）。在这个分区结束后，该基准就处于数列的中间位置。这个称为分区操作</li><li>递归的把小于基准值圆的子数列和大于基准值元素的子序列排序。</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序号了。虽然一直递归下去，但是这个算法总会结束，因为在每次的迭代中，它至少会吧一个元素白发哦它最后的位置去。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：log2n</li><li>最坏时间复杂度：O(n²)</li><li>稳定性：不稳定</li></ul><p>从一开始快速排序平均花费O（nlog2n）时间的描述并不明显，但是不能观察到的是分区运算，数组的元素都会在每一次循环中走访一次，使用O（n）的时间，<br>在最好的情况，我们运行一次分区，我们就把一个数列分为几个近相等的片段。这个意思就是每次递归调用处理一半大小的数列。因此，在到达大小为一的数列前，我们只要做log2n次嵌套的调用。这个意思就是调用树的深度是O(log2n)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(alist, first, end)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    快速排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param first: 列表起始位置</span></span><br><span class="line"><span class="string">    :param end: 列表结束位置</span></span><br><span class="line"><span class="string">    :param alist: 传入一个列表参数</span></span><br><span class="line"><span class="string">    :return: 排序</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> first &gt;= end:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    mid_value = alist[first]</span><br><span class="line">    low = first</span><br><span class="line">    height = end</span><br><span class="line">    <span class="keyword">while</span> low &lt; height:</span><br><span class="line">        <span class="comment"># height 左移</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; height <span class="keyword">and</span> alist[height] &gt;= mid_value:</span><br><span class="line">            height -= <span class="number">1</span></span><br><span class="line">        alist[low] = alist[height]</span><br><span class="line">        <span class="keyword">while</span> low &lt; height <span class="keyword">and</span> alist[low] &lt; mid_value:</span><br><span class="line">            low += <span class="number">1</span></span><br><span class="line">        alist[height] = alist[low]</span><br><span class="line">    <span class="comment"># 从循环退出时，low = height</span></span><br><span class="line">    alist[low] = mid_value</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对low左边的列表执行快速排序</span></span><br><span class="line">    quick_sort(alist, first, low<span class="number">-1</span>)</span><br><span class="line">    <span class="comment"># low右边的列表执行快速排序</span></span><br><span class="line">    quick_sort(alist, low+<span class="number">1</span>, end)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = [<span class="number">22</span>, <span class="number">55</span>, <span class="number">2</span>, <span class="number">66</span>, <span class="number">3</span>, <span class="number">55</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">33</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    n = len(li)</span><br><span class="line">    quick_sort(li, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">    print(li)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>希尔排序</title>
      <link href="/2019/08/15/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/15/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><p>希尔排序是插入排序的一种，也称缩小增量排序，是直接插入排序算法的一种更搞笑的改进版本，希尔排序是非稳定排序算法。</p><h4 id="希尔排序过程"><a href="#希尔排序过程" class="headerlink" title="希尔排序过程"></a>希尔排序过程</h4><p>希尔排序的基本思想是：将数组列在一个表中并对列分别进行Haru排序，重复这过程，不过没用更长的列来进行，最后整个表就只有一列了，将数组转换至表是为了更好地理解这算法，算法本身还是使用数组进行排序。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：根据步长序列的不同而不同</li><li>最坏时间复杂度：O(n²)</li><li>稳定性：不稳定</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">"""希尔排序"""</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    gap = n // <span class="number">2</span>        <span class="comment"># 间距</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 按步长进行插入排序</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(gap, n):</span><br><span class="line">            i = j</span><br><span class="line">            <span class="keyword">while</span> i &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span> alist[i] &lt; alist[i - gap]:</span><br><span class="line">                    alist[i], alist[i-gap] = alist[i-gap], alist[i]</span><br><span class="line">                    i -= gap</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 缩短gap步长</span></span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    li = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">12</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [2, 4, 6, 2, 45, 34, 12]</span></span><br><span class="line">    shell_sort(li)</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [2, 2, 4, 6, 12, 34, 45]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>插入排序</title>
      <link href="/2019/08/15/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/15/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><p>插入排序是一种简单直观的排序算法，他的工作原理是构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，从后面向前扫描中，需要反复吧已排序元素逐步向后挪位，为新元素提供插入空间</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><ul><li>最优时间复杂度：O(n)    （升序排列，序列已经处于升序状态）</li><li>最坏时间复杂度：O(n²)</li><li>稳定性：稳定</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">"""选择排序"""</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(alist)<span class="number">-1</span>):    <span class="comment"># j：0~n-2</span></span><br><span class="line"></span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>, len(alist)):  <span class="comment"># 后一个开始比</span></span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    li = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">12</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [2, 4, 6, 2, 45, 34, 12]</span></span><br><span class="line">    select_sort(li)</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [2, 2, 4, 6, 12, 34, 45]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2019/08/15/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/15/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>选择排序是一种简单直观的排序算法，他的工作原理如下。</p><ol><li>首先在未排序序列中找到最小（大）的元素，存放到排序序列的起始位置，</li><li>然后再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾，</li><li>以此类推，知道所有元素排序完毕</li></ol><ul><li>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则他不会被移动。</li><li>选择排序每次交换一对元素，他们当中至少有一个奖杯移到其最终位置上，因此对n个元素的表进行排序总共进行之多n-1次交换。在所有的完全依靠交换去移动元素的方法中，选择排序属于非常好的一种。</li></ul><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>最优时间复杂度：O(n²)<br>最坏时间复杂度：O(n²）<br>稳定性：不稳定（考虑升序每次选择最大情况）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">select_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">"""选择排序"""</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">0</span>, len(alist)<span class="number">-1</span>):    <span class="comment"># j：0~n-2</span></span><br><span class="line"></span><br><span class="line">        min_index = j</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(j+<span class="number">1</span>, len(alist)):  <span class="comment"># 后一个开始比</span></span><br><span class="line">            <span class="keyword">if</span> alist[min_index] &gt; alist[i]:</span><br><span class="line">                min_index = i</span><br><span class="line">        alist[j], alist[min_index] = alist[min_index], alist[j]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    li = [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">34</span>, <span class="number">12</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [2, 4, 6, 2, 45, 34, 12]</span></span><br><span class="line">    select_sort(li)</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [2, 2, 4, 6, 12, 34, 45]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2019/08/14/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2019/08/14/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>冒泡排序是一种简单的排序算法<br>它重复的遍历要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。遍历数列的工作是重复的进行直到没有需要交换，也就是说该数列排序完成</li><li>最优时间复杂度：O(n) 遍历一次没有发现可以交换的元素</li><li>最坏时间复杂度O(n²)</li><li>稳定性：稳定</li></ul><p>冒泡排序法的运作过程：</p><ol><li>比较相邻的元素。如果第一个比第二个大（升序），就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾最后一对，这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个</li><li>持续每次对越来越少的元素重复上面的步骤，知道没有任何一个数字需要比较</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="comment"># 基于顺序表</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(alist)</span>:</span></span><br><span class="line">    <span class="string">"""冒泡排序"""</span></span><br><span class="line">    n = len(alist)</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(n<span class="number">-1</span>):        <span class="comment"># 走的次数</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, n<span class="number">-1</span>-j):       <span class="comment"># 依次遍历元素对比大小，许要n-1次</span></span><br><span class="line">            <span class="comment"># 从头走到尾</span></span><br><span class="line">            <span class="keyword">if</span> alist[i] &gt; alist[i+<span class="number">1</span>]:</span><br><span class="line">                alist[i], alist[i+<span class="number">1</span>] = alist[i+<span class="number">1</span>], alist[i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    li = [<span class="number">34</span>, <span class="number">35</span>, <span class="number">643</span>, <span class="number">54</span>, <span class="number">63</span>, <span class="number">42</span>]</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [34, 35, 643, 54, 63, 42]</span></span><br><span class="line">    bubble_sort(li)</span><br><span class="line">    print(li)</span><br><span class="line">    <span class="comment"># [34, 35, 42, 54, 63, 643]</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>排序与搜索</title>
      <link href="/2019/08/14/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2/"/>
      <url>/2019/08/14/%E6%8E%92%E5%BA%8F%E4%B8%8E%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<p>排序算法是一种能将一串数据按照特点顺序进行排列的一种算法</p><h4 id="排序的稳定性"><a href="#排序的稳定性" class="headerlink" title="排序的稳定性"></a>排序的稳定性</h4><p>稳定性：稳定排序算法会让原本有相等键值的记录维持相对次序，也就是如果一个排序算法是稳定的，当有两个相等键值的记录R和S，且在原本列表R出现S之前。稳定排序之后次序还是R出现在S之前。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="/2019/08/14/%E9%98%9F%E5%88%97/"/>
      <url>/2019/08/14/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><ul><li>队列是只允许在一端进行插入操作，而在另一端进行删除操作的线性表</li><li>队列是一种先进先出的线性表，允许插入的一端为队尾，允许删除的一端为队头</li><li>队列不允许在中间部位进行操作！</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 定义一个空列表保存数据(顺序表）</span></span><br><span class="line">        self.__list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">enqueue</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个元素item"""</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">dequeue</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Queue()</span><br><span class="line">    s.enqueue(<span class="number">1</span>)</span><br><span class="line">    s.enqueue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(s.dequeue())</span><br><span class="line">    print(s.dequeue())</span><br></pre></td></tr></table></figure><ul><li>双端队列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Deque</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双端队列"""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 定义一个空列表保存数据(顺序表）</span></span><br><span class="line">        self.__list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_front</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""往队列中添加一个元素item"""</span></span><br><span class="line">        self.__list.insert(<span class="number">0</span>, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_rear</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_front</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""从头部删除一个元素"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop_rear</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""判断队列是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回队列大小"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Deque()</span><br><span class="line">    s.enqueue(<span class="number">1</span>)</span><br><span class="line">    s.enqueue(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(s.dequeue())</span><br><span class="line">    print(s.dequeue())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="/2019/08/14/%E6%A0%88/"/>
      <url>/2019/08/14/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<h4 id="栈结构实现"><a href="#栈结构实现" class="headerlink" title="栈结构实现"></a>栈结构实现</h4><p>栈可以用顺序表实现，也可以用链表实现。</p><h4 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h4><ul><li>Stack() 创建一个新的空栈</li><li>push(item) 添加一个新的元素item到栈顶</li><li>pop() 弹出栈顶元素</li><li>peek() 返回栈顶元素</li><li>is_empty() 判断栈是否为空</li><li>size() 返回栈的元素个数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""?"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""????"""</span></span><br><span class="line">        self.__list.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""??????"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__list.pop()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">peek</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""??????"""</span></span><br><span class="line">        <span class="keyword">if</span> self.__list:</span><br><span class="line">            <span class="keyword">return</span> self.__list[<span class="number">-1</span>]      <span class="comment"># -1????????</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""???????"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__list == []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">size</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""????????"""</span></span><br><span class="line">        <span class="keyword">return</span> len(self.__list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    s = Stack()</span><br><span class="line">    s.push(<span class="number">1</span>)</span><br><span class="line">    s.push(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    print(s.pop())</span><br><span class="line">    print(s.pop())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单向循环链表</title>
      <link href="/2019/08/12/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/08/12/%E5%8D%95%E5%90%91%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>难</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单向循环链表的节点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCycleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单向循环链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node=None)</span>:</span></span><br><span class="line">        self.__head = node   <span class="comment"># ****定义成私有的</span></span><br><span class="line">        <span class="keyword">if</span> node:</span><br><span class="line">            node.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表长度"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="comment"># cut游标，用来移动遍历结点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># count 记录数量</span></span><br><span class="line">        count = <span class="number">1</span>   <span class="comment"># 注意这个是1了</span></span><br><span class="line">        <span class="keyword">while</span> cur.next != self.__head:  <span class="comment"># 不用cur.next，用的话最后一个就直接跳出，不执行加1了</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历整个链表"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.next != self.__head:</span><br><span class="line">            print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="comment"># 退出循环，cur执行为节点，但为节点的元素未打印</span></span><br><span class="line">        print(cur.elem)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表表头添加，头插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self.__head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.__head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 退出循环，cur指向尾结点</span></span><br><span class="line">            node.next = self.__head</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""尾插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        cur = self.__head   <span class="comment"># 从头往后走，走到最后</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 判断是否为空</span></span><br><span class="line">            self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.__head:     <span class="comment"># 用的是cur.next</span></span><br><span class="line">                cur = cur.next      <span class="comment"># 往后移动</span></span><br><span class="line">            node.next = self.__head</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""指定位置添加元素</span></span><br><span class="line"><span class="string">        :param pos: 从0开始</span></span><br><span class="line"><span class="string">        :param item:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; self.length()<span class="number">-1</span>:</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prior = self.__head     <span class="comment"># 直接去找指的，不是__head</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos<span class="number">-1</span>:    <span class="comment"># 不是小于等于，寻找前一个节点</span></span><br><span class="line">                prior = prior.next</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当循环退出后，prior指向pos - 1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = prior.next</span><br><span class="line">            prior.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点</span></span><br><span class="line"><span class="string">        :param item:00</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        prior = <span class="literal">None</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur.next != self.__head:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断是否是头结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                    <span class="comment"># 头结点的情况</span></span><br><span class="line">                    <span class="comment"># 找尾结点</span></span><br><span class="line">                    rear = self.__head</span><br><span class="line">                    <span class="keyword">while</span> rear.next != self.__head:</span><br><span class="line">                        rear = rear.next</span><br><span class="line">                    self.__head = cur.next</span><br><span class="line">                    rear.next = self.__head</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 中间节点</span></span><br><span class="line">                    prior.next = cur.next</span><br><span class="line">                    print(<span class="string">"删除%d成功"</span> % item)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prior = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">            <span class="keyword">if</span> cur == self.__head:</span><br><span class="line">                self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prior.next = cur.next</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"没有这个元素，删除失败"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span> print(<span class="string">"空的，查找%d失败"</span> % item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self.__head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self.__head:     <span class="comment"># 是cur不是cur.next</span></span><br><span class="line">                <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            print(<span class="string">"查找%d失败,没有这个元素"</span> % item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ll = SingleCycleLinkList()</span><br><span class="line">    print(ll.is_empty())</span><br><span class="line"></span><br><span class="line">    print(ll.length())</span><br><span class="line">    ll.add(<span class="number">0</span>)</span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">5</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.add(<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 20 0 1 2 5 3</span></span><br><span class="line">    ll.insert(<span class="number">-1</span>, <span class="number">9</span>)</span><br><span class="line">    ll.insert(<span class="number">3</span>, <span class="number">90</span>)</span><br><span class="line">    <span class="comment"># 9 20 0 90 1 2 5 3</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    print(<span class="string">"\n********************"</span>)</span><br><span class="line">    ll.search(<span class="number">3233</span>)</span><br><span class="line">    ll.remove(<span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/2019/08/11/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/08/11/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="coding-utf-8"><a href="#coding-utf-8" class="headerlink" title="coding:utf-8"></a>coding:utf-8</h1><p>class Node(object):<br>    “””生成双向链表的节点”””<br>    def <strong>init</strong>(self, item):<br>        self.item = item<br>        self.next = None<br>        self.prior = None</p><p>class DoubleLinkList(object):<br>    “””双链表”””<br>    def <strong>init</strong>(self, node=None):<br>        self.__head = node   # ****定义成私有的</p><pre><code>def is_empty(self):    &quot;&quot;&quot;链表是否为空&quot;&quot;&quot;    return self.__head is Nonedef length(self):    &quot;&quot;&quot;链表长度&quot;&quot;&quot;    # cut游标，用来移动遍历结点    cur = self.__head    # count 记录数量    count = 0   # 注意这个是0    while cur is not None:  # 不用cur.next，用的话最后一个就直接跳出，不执行加1了        count += 1        cur = cur.next    return countdef travel(self):    &quot;&quot;&quot;遍历整个链表&quot;&quot;&quot;    cur = self.__head    while cur is not None:        print(cur.item, end=&quot; &quot;)        cur = cur.nextdef add(self, item):    &quot;&quot;&quot;链表表头添加，头插法&quot;&quot;&quot;    node = Node(item)    if self.is_empty():        # 如果是空链表，将_head指向node        self._head = node    else:        # 将node的next指向_head的头节点        node.next = self._head        # 将_head的头节点的prev指向node        self._head.prior = node        # 将_head 指向node        self._head = nodedef append(self, item):    &quot;&quot;&quot;尾插法&quot;&quot;&quot;    node = Node(item)    cur = self.__head   # 从头往后走，走到最后    if self.__head is None:  # 判断是否为空        self.__head = node    else:        while cur.next is not None:     # 用的是cur.next            cur = cur.next      # 往后移动        cur.next = node        node.prior = curdef insert(self, pos, item):    &quot;&quot;&quot;指定位置添加元素    :param pos: 从0开始    :param item:    &quot;&quot;&quot;    if pos &lt;= 0:        self.add(item)    elif pos &gt; self.length():        self.append(item)    else:        cur = self.__head     # 直接去找指的，不是__head        count = 0        while count &lt; pos-1:    # 不是小于等于，寻找前一个节点            cur = cur.next            count += 1        # 当循环退出后，prior指向pos位置        node = Node(item)        node.next = cur        node.prior = cur.prior        cur.prior.next = node        cur.prev = nodedef remove(self, item):    &quot;&quot;&quot;删除结点    :param item:00    &quot;&quot;&quot;    cur = self.__head    while cur is not None:        if cur.item == item:            # 先判断是否是头结点            if cur is self.__head:                self.__head = cur.next                if cur.next:                    # 判断链表是否只有一个结点                    cur.next.prior = None            else:                cur.prior.next = cur.next                if cur.next:    # 达到最后                    cur.next.prior = cur.prior            # del cur                print(&quot;删除%d成功&quot; % item)            break        else:            prior = cur            cur = cur.next    else:        print(&quot;没有这个元素，删除失败&quot;)def search(self, item):    cur = self.__head    count = 0    if cur is None:        return print(&quot;空的，查找%d失败&quot; % item)    else:        while cur is not None:     # 是cur不是cur.next            if cur.item == item:                return count            else:                cur = cur.next                count += 1        print(&quot;查找%d失败,没有这个元素&quot; % item)</code></pre><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    ll = DoubleLinkList()<br>    print(ll.is_empty())</p><pre><code>print(ll.length())ll.add(0)ll.append(1)ll.append(2)ll.append(5)ll.append(3)ll.add(20)# 20 0 1 2 5 3ll.insert(-1, 9)ll.insert(3, 90)# 9 20 0 90 1 2 5 3ll.travel()print(&quot;\n********************&quot;)ll.search(3233)ll.remove(5)ll.travel()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="/2019/08/11/%E9%93%BE%E8%A1%A8/"/>
      <url>/2019/08/11/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p>单向链表也叫单链表，是链表中最简单的一种形式，他的每一个节点包含两个域，一个信息域和一个链接域。这个链表指向链表中的下一个节点，而最后一个节点的链接域则执行一个空值。</p><h4 id="节点实现"><a href="#节点实现" class="headerlink" title="节点实现"></a>节点实现</h4><h4 id="单链表的操作"><a href="#单链表的操作" class="headerlink" title="单链表的操作"></a>单链表的操作</h4><ul><li>is_empty()链表是否为空</li><li>length()链表的长度</li><li>travel()遍历整个链表</li><li>add(item)链表头部添加元素</li><li>append(item）链表尾部添加元素</li><li>insert(ops, item)指定位置添加元素</li><li>remove(item)删除节点</li><li>seach(item)查找节点是否存在</li></ul><ol start="2"><li><code>_x</code>:单前置下划线，私有化属性或方法，禁止通过form modules import * 导入，但是类和对象可以访问</li><li><code>__xx</code> ：双前置下划线，避免与子类中的属性名冲突，无法在外部直接访问（名字重整所以访问不到），类对象和子类不能访问</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表的节点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""单链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, node=None)</span>:</span></span><br><span class="line">        self.__head = node   <span class="comment"># ****定义成私有的</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self.__head <span class="keyword">is</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表长度"""</span></span><br><span class="line">        <span class="comment"># cut游标，用来移动遍历结点</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="comment"># count 记录数量</span></span><br><span class="line">        count = <span class="number">0</span>   <span class="comment"># 注意这个是0</span></span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:  <span class="comment"># 不用cur.next，用的话最后一个就直接跳出，不执行加1了</span></span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历整个链表"""</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表表头添加，头插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self.__head     <span class="comment"># 不是self.__head.next,__head存放的是下一个的地址，所以可以直接等于</span></span><br><span class="line">        self.__head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""尾插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        cur = self.__head   <span class="comment"># 从头往后走，走到最后</span></span><br><span class="line">        <span class="keyword">if</span> self.__head <span class="keyword">is</span> <span class="literal">None</span>:  <span class="comment"># 判断是否为空</span></span><br><span class="line">            self.__head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> cur.next <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:     <span class="comment"># 用的是cur.next</span></span><br><span class="line">                cur = cur.next      <span class="comment"># 往后移动</span></span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""指定位置添加元素</span></span><br><span class="line"><span class="string">        :param pos: 从0开始</span></span><br><span class="line"><span class="string">        :param item:</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; self.length()<span class="number">-1</span>:</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            prior = self.__head     <span class="comment"># 直接去找指的，不是__head</span></span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos<span class="number">-1</span>:    <span class="comment"># 不是小于等于，寻找前一个节点</span></span><br><span class="line">                prior = prior.next</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">            <span class="comment"># 当循环退出后，prior指向pos - 1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = prior.next</span><br><span class="line">            prior.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点</span></span><br><span class="line"><span class="string">        :param item:00</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        prior = <span class="literal">None</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断是否是头结点</span></span><br><span class="line">                <span class="keyword">if</span> cur <span class="keyword">is</span> self.__head:</span><br><span class="line">                    self.__head = cur.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    prior.next = cur.next</span><br><span class="line">                <span class="comment"># del cur</span></span><br><span class="line">                    print(<span class="string">"删除%d成功"</span> % item)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                prior = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"没有这个元素，删除失败"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        cur = self.__head</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> cur <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> print(<span class="string">"空的，查找%d失败"</span> % item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span> cur <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:     <span class="comment"># 是cur不是cur.next</span></span><br><span class="line">                <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                    <span class="keyword">return</span> count</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur = cur.next</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">            print(<span class="string">"查找%d失败,没有这个元素"</span> % item)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    ll = SingleLinkList()</span><br><span class="line">    print(ll.is_empty())</span><br><span class="line"></span><br><span class="line">    print(ll.length())</span><br><span class="line">    ll.add(<span class="number">0</span>)</span><br><span class="line">    ll.append(<span class="number">1</span>)</span><br><span class="line">    ll.append(<span class="number">2</span>)</span><br><span class="line">    ll.append(<span class="number">5</span>)</span><br><span class="line">    ll.append(<span class="number">3</span>)</span><br><span class="line">    ll.add(<span class="number">20</span>)</span><br><span class="line">    <span class="comment"># 20 0 1 2 5 3</span></span><br><span class="line">    ll.insert(<span class="number">-1</span>, <span class="number">9</span>)</span><br><span class="line">    ll.insert(<span class="number">3</span>, <span class="number">90</span>)</span><br><span class="line">    <span class="comment"># 9 20 0 90 1 2 5 3</span></span><br><span class="line">    ll.travel()</span><br><span class="line">    print(<span class="string">"\n********************"</span>)</span><br><span class="line">    ll.search(<span class="number">3233</span>)</span><br><span class="line">    ll.remove(<span class="number">5</span>)</span><br><span class="line">    ll.travel()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>顺序表</title>
      <link href="/2019/08/10/%E9%A1%BA%E5%BA%8F%E8%A1%A8/"/>
      <url>/2019/08/10/%E9%A1%BA%E5%BA%8F%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="顺序表增加元素"><a href="#顺序表增加元素" class="headerlink" title="顺序表增加元素"></a>顺序表增加元素</h4><p>尾端加入元素，时间复杂度为O(1)<br>保序的元素加入，时间复杂度为O(n)</p><h4 id="顺序表删除元素"><a href="#顺序表删除元素" class="headerlink" title="顺序表删除元素"></a>顺序表删除元素</h4><p>删除表尾元素，时间复杂度为O(1)<br>保序的元素加入，时间复杂度为O(n)</p><h4 id="python中的顺序表"><a href="#python中的顺序表" class="headerlink" title="python中的顺序表"></a>python中的顺序表</h4><p>python中的list和tuple两种类型采用了顺序表的实现技术，具有顺序表的所有性质。<br>tuple是不可变类型，即不变的顺序表，因此不支持改变其内部状态的任何操作，而其他方面，则与list的性质类似<br>list的基本实现技术<br>Python标准类型list就是一种元素可变的线性表，可以加入和删除元素，并在各种操作中维持已有元素的顺序，而且还具有以下行为特征：</p><ol><li>基于下标的高效元素访问和更新，时间复杂度应该是O(1)</li><li>为满足该特征，应该采用顺序表技术，表中元素保存在一块连续的存储区中。</li><li>允许加入任意该元素，而且在不断加入的过程中，表对象的标识（函数的id的值）不变</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>复杂度</title>
      <link href="/2019/08/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
      <url>/2019/08/09/%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="python-内置类型性能分析python-内置类型性能分析"><a href="#python-内置类型性能分析python-内置类型性能分析" class="headerlink" title="python 内置类型性能分析python 内置类型性能分析"></a>python 内置类型性能分析python 内置类型性能分析</h3><h4 id="list-内置操作的时间复杂度"><a href="#list-内置操作的时间复杂度" class="headerlink" title="list 内置操作的时间复杂度"></a>list 内置操作的时间复杂度</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">index[x] 取值O(<span class="number">1</span>)</span><br><span class="line">index assignment赋值O(<span class="number">1</span>)</span><br><span class="line">append尾部追加O(<span class="number">1</span>)</span><br><span class="line">pop尾部弹出O(<span class="number">1</span>)</span><br><span class="line">pop(i)指定位置弹出O(n）</span><br><span class="line">insert(i , item)指定位置插入O(n)  </span><br><span class="line"><span class="keyword">del</span> operaterO(n)</span><br></pre></td></tr></table></figure><h4 id="timeit模块"><a href="#timeit模块" class="headerlink" title="timeit模块"></a>timeit模块</h4><p>timeit模块可以用来测试一小段Python代码的执行速度</p><p><strong>class timeit.Timer(stmt=’pass’, setup=’pass’, timer=<timer function>)</timer></strong></p><p>Timer 是测量小段代码执行速度的类。<br>stmt参数是要测试的代码语句（statement）<br>setup参数是运行代码需要的的设置<br>timer参数是一个定时器函数，与平台有关</p><p><strong>timeit.Timer.timeit(number=1000000)</strong></p><p>Timer类中测试语句的执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次，方法返回执行飞马的平均耗时，一个float类型的秒数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> timeit <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t1</span><span class="params">()</span>:</span></span><br><span class="line">    li = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        li.append(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t2</span><span class="params">()</span>:</span></span><br><span class="line">    li = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        li = li + [i]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 列表生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t3</span><span class="params">()</span>:</span></span><br><span class="line">    li = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>)]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t4</span><span class="params">()</span>:</span></span><br><span class="line">    li = list(range(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与+不一样</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t5</span><span class="params">()</span>:</span></span><br><span class="line">    li = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        li.extend([i])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 与append对比头部尾部添加</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">t6</span><span class="params">()</span>:</span></span><br><span class="line">    li = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">        li.insert(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">timer1 = Timer(<span class="string">"t1()"</span>, <span class="string">"from __main__ import t1"</span>)</span><br><span class="line">print(<span class="string">"append:"</span>, timer1.timeit(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">timer2 = Timer(<span class="string">"t2()"</span>, <span class="string">"from __main__ import t2"</span>)</span><br><span class="line">print(<span class="string">"+:"</span>, timer2.timeit(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">timer3 = Timer(<span class="string">"t3()"</span>, <span class="string">"from __main__ import t3"</span>)</span><br><span class="line">print(<span class="string">"[i for i in range]:"</span>, timer3.timeit(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">timer4 = Timer(<span class="string">"t4()"</span>, <span class="string">"from __main__ import t4"</span>)</span><br><span class="line">print(<span class="string">"list(range()):"</span>, timer4.timeit(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">timer5 = Timer(<span class="string">"t5()"</span>, <span class="string">"from __main__ import t5"</span>)</span><br><span class="line">print(<span class="string">"extend:"</span>, timer5.timeit(<span class="number">1000</span>))</span><br><span class="line"></span><br><span class="line">timer6 = Timer(<span class="string">"t6()"</span>, <span class="string">"from __main__ import t6"</span>)</span><br><span class="line">print(<span class="string">"insert[0]:"</span>, timer6.timeit(<span class="number">1000</span>))</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">append: <span class="number">0.07670579999999999</span></span><br><span class="line">+: <span class="number">3.3817863</span></span><br><span class="line">[i <span class="keyword">for</span> i <span class="keyword">in</span> range]: <span class="number">0.06815369999999987</span></span><br><span class="line">list(range()): <span class="number">0.027385799999999794</span></span><br><span class="line">extend: <span class="number">0.20605129999999994</span></span><br><span class="line">insert: <span class="number">0.7449211</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>飞机大战</title>
      <link href="/2019/08/07/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/"/>
      <url>/2019/08/07/%E9%A3%9E%E6%9C%BA%E5%A4%A7%E6%88%98/</url>
      
        <content type="html"><![CDATA[<p>可以将图片素材绘制到游戏的窗口上，开发游戏之前需要先知道如何建立游戏窗口！</p><h4 id="游戏的初始化和退出"><a href="#游戏的初始化和退出" class="headerlink" title="游戏的初始化和退出"></a>游戏的初始化和退出</h4><ul><li>要使用pygame提供的所有功能之前，需要调用 init 方法</li><li>在游戏结束前需要调用 quit 方法</li></ul><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.init()</td><td>导入并初始化所有pygame模块，使用其他模块之前，必须先调用init 方法</td></tr><tr><td>pygame.quit()</td><td>卸载所有pygame模块，在游戏结束之前调用</td></tr></tbody></table><h4 id="游戏中的坐标系"><a href="#游戏中的坐标系" class="headerlink" title="游戏中的坐标系"></a>游戏中的坐标系</h4><p>坐标系</p><ul><li>原点在左上角（0, 0）</li><li>x轴水平方向向右，逐渐增加</li><li>y轴垂直方向向下，逐渐增加</li></ul><ul><li>在游戏中，所有可见的元素都是以矩形区域来描述位置的<ul><li>要描述一个矩形区域有四个要素：（x, y）（width, height）</li></ul></li><li>pygame专门提供了一个类 pygame.Rect 用于描述矩形区域<br><code>Rect(x, y, width, height) -&gt; Rect</code><br>pygame.Rect是一个比较特殊的类，内部知识封装了一些数字计算，不执行pygame.init()方法同样能够直接使用</li></ul><h4 id="创建游戏主窗口"><a href="#创建游戏主窗口" class="headerlink" title="创建游戏主窗口"></a>创建游戏主窗口</h4><p>pygame 专门提供了一个模块 pygame.display用于创建、管理游戏窗口</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>pygame.display.set_modle()</td><td>初始化游戏显示窗口</td></tr><tr><td>pygame.display.update()</td><td>刷新屏幕内容显示，稍后使用</td></tr></tbody></table><p>set_mode 方法<br>set_mode(resolution(0, 0), flags=0,depth=0)-&gt;Surface</p><ul><li>作用–创建游戏显示窗口</li><li>参数<ul><li>resolution指定屏幕的宽和高，默认创建的窗口大小和屏幕大小一致</li><li>flags参数指定屏幕的附加选项，例如是否全屏等等，默认不需要传递</li><li>depth 参数表示颜色的数位，默认自动匹配</li></ul></li><li>返回值<ul><li>暂时可以理解为游戏的屏幕，游戏的元素都需要被会知道游戏的屏幕上</li></ul></li><li>注意：必须使用变量记录set_mode方法的返回结果！因为：后续的图像都基于这个返回结果</li></ul><h4 id="简单的游戏循环"><a href="#简单的游戏循环" class="headerlink" title="简单的游戏循环"></a>简单的游戏循环</h4><ul><li><p>为了做到游戏程序启动后，不会立即退出，通常会在游戏程序中增加一个游戏循环</p></li><li><p>所谓游戏循环就是一个无限循环</p></li><li><p>在创建游戏窗口代码下方，增加一个无限循环</p><ul><li>注意：游戏窗口不需要重复创建</li></ul></li><li><p>游戏由两个部分组成<br>游戏初始化：<br>1，设置游戏窗口。<br>2，绘制图像初始位置。<br>3，设置游戏时钟<br>游戏循环：<br>1，设置刷新帧率。<br>2，检测用户交互。<br>3，更新所有图像位置。<br>4，更新屏幕显示</p></li></ul><h4 id="理解图像并实现图片绘制"><a href="#理解图像并实现图片绘制" class="headerlink" title="理解图像并实现图片绘制"></a>理解图像并实现图片绘制</h4><ul><li>在游戏中，能看到的游戏元素大多都是图像<ul><li>图像文件时保存在磁盘上的，如果需要使用，第一步就需要被加载到内存</li></ul></li><li>要在屏幕上看到某一图像内容，需要按照三个步骤：<ol><li>使用 pygame.image.load() 加载图像的数据</li><li>使用游戏屏幕对象，调用 blit(图像，位置) 方法将图像绘制到指定位置</li><li>调用 pygame.display.update() 方法更新整个屏幕的显示1. </li></ol></li></ul><p>提示：先要在屏幕上看到绘制的结果，就一定要调用 pygame.display.update( ) 方法</p><h4 id="理解update-方法的作用"><a href="#理解update-方法的作用" class="headerlink" title="理解update() 方法的作用"></a>理解update() 方法的作用</h4><p>可以在 screen 对象完成所有 blit 方法治好，统一调用一次 display.update 方法，统一可以在屏幕上看到最终的绘制结果</p><ul><li>使用display.set_mode()创建的 screen 对象时一个内存中的屏幕数据对象<ul><li>可以理解成是油画中的画布</li></ul></li><li>screen.blit 方法可以在画布上绘制很多图像<ul><li>这些图像有可能会彼此重叠或者覆盖</li></ul></li><li>display.update() 会将画布的最终结果绘制在屏幕上，这样可以提高屏幕的绘制效率，增加游戏的流畅度</li></ul><p>每一次调用update()方法之前，需要把所有的游戏图像都重新绘制一遍，而且应该最先重新绘制背景图像</p><h4 id="游戏时钟"><a href="#游戏时钟" class="headerlink" title="游戏时钟"></a>游戏时钟</h4><ul><li>pygame专门提供了一个类 pygame.time.Clock 可以非常方便的设置屏幕绘制速度——刷新帧率</li><li>要使用时钟对象需要两步：<ul><li>1，在游戏内初始化创建一个时钟对象</li><li>2，在游戏循环中让时钟对象调用 tick(帧率) 方法</li></ul></li><li>tick 方法会根据上次被调用的时间，自动设置游戏循环中的延时</li></ul><h4 id="在游戏循环中监听事件"><a href="#在游戏循环中监听事件" class="headerlink" title="在游戏循环中监听事件"></a>在游戏循环中监听事件</h4><p>代码实现</p><ul><li>pygame 中通过pygame.event.get() 可以获得用户当前所做动作的事件列表<ul><li>用户可以同一时间做很多事情</li></ul></li><li>提示：这段代码非常的固定，几乎所有的pygame游戏都大同小异</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 可以指定循环体内代码执行的帧率</span></span><br><span class="line">    clock.tick(<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 捕获对象,事件监听</span></span><br><span class="line">    even_list = pygame.event.get()</span><br><span class="line">    <span class="keyword">for</span> event <span class="keyword">in</span> even_list:</span><br><span class="line">        <span class="keyword">if</span> event.type == pygame.QUIT:</span><br><span class="line">            print(<span class="string">"退出游戏。。"</span>)</span><br><span class="line">            <span class="comment"># 卸载所有模块</span></span><br><span class="line">            pygame.quit()</span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 直接退出系统</span></span><br><span class="line">            exit()</span><br></pre></td></tr></table></figure><hr><p>title: 飞机大战续<br>date: 2019-08-08 15:34:01</p><h2 id="tags"><a href="#tags" class="headerlink" title="tags:"></a>tags:</h2><h4 id="精灵和精灵组"><a href="#精灵和精灵组" class="headerlink" title="精灵和精灵组"></a>精灵和精灵组</h4><p>为了简化开法步骤，pygame提供了两个类<br>pygame.sprite.Sprite ——存储图像数据image和位置rect的对象<br>pygame.sprite.Group</p><p>精灵（需要派生子类）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">image 记录图像数据</span><br><span class="line">rect 记录在屏幕上的位置</span><br><span class="line">update(*arge)：更新精灵位置</span><br><span class="line">kill()：从所有组中删除</span><br></pre></td></tr></table></figure><p>精灵组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">__init__(self, * 精灵):</span><br><span class="line">add(*spriites) ：向组中增加精灵</span><br><span class="line">sprites()：返回所有精灵列表</span><br><span class="line">update(*args )：让组中所有精灵调用 update方法</span><br><span class="line">draw(Surface)：将组中所有精灵的 image，绘制到 Surface的 rect 位置</span><br></pre></td></tr></table></figure><p><strong>游戏</strong></p><ul><li><p>游戏初始化：</p><ol><li>创建精灵</li><li>创建精灵组</li></ol></li><li><p>游戏循环</p><ol><li>精灵组.update()</li><li>精灵组.draw(screen)</li><li>pygame.display.update()</li></ol></li></ul><h5 id="派生精灵子类"><a href="#派生精灵子类" class="headerlink" title="派生精灵子类"></a>派生精灵子类</h5><p>1，新建 plane_sprites.py 文件<br>2，定义 GameSpriiite 继承自 pygame.sprite.Sprite<br><strong>注意</strong></p><ul><li>如果一个类的父类不是object</li><li>在重写初始化方法时，一定要先 super() 一下父类的<code>__init__</code>方法</li><li>保证父类中实现的<code>__init__</code>代码能够正常执行</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GameSprite：</span><br><span class="line">image</span><br><span class="line">rect</span><br><span class="line">speed</span><br><span class="line">__init__(self, image_name, speed=<span class="number">1</span>):</span><br><span class="line">update(self):</span><br></pre></td></tr></table></figure><p><strong>属性</strong></p><ul><li>image 精灵图像，使用 image_name 加载</li><li>rect 精灵大小，默认使用图像大小</li><li>speed 精灵移动速度，默认为1</li></ul><p><strong>方法</strong></p><ul><li>update 每次更新屏幕时在游戏循环内调用</li><li>让精灵的 self.rect.y += self.speed</li></ul><p><strong>提示</strong></p><ul><li>image 的 get_rect() 方法，可以返回 pygame.Rect(0,0,图像宽, 图像高)的对象</li></ul><h4 id="使用游戏精灵和精灵组创建敌机"><a href="#使用游戏精灵和精灵组创建敌机" class="headerlink" title="使用游戏精灵和精灵组创建敌机"></a>使用游戏精灵和精灵组创建敌机</h4><p><strong>步骤</strong><br>1，使用 from 导入 plane_sprites模块</p><ul><li>from 导入的模块可以直接使用</li><li>import导入的模块需要通过 模块名. 来使用</li></ul><p>2，在游戏初始化创建精灵对象的精灵组对象<br>3，在游戏循环中，让经理组分别调用 update() 和 draw(screen)方法</p><p><strong>职责</strong></p><ul><li>精灵<ul><li>封装图像 image、位置rect 和速度 speed</li><li>提供 update() 方法，根据游戏需求，更新位置 rect</li></ul></li><li>精灵族<ul><li>包含多个精灵对象</li><li>update方法，让精灵中的所有精灵调用update方法更新位置</li><li>draw(screen) 方法，在 screen 上绘制精灵组中的所有精灵</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>51.eval函数</title>
      <link href="/2019/08/07/51-eval%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/07/51-eval%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>eval()函数十分强大————将字符串当成有效的表达式来求值并返回计算结果<br>基本的数学计算<br>字符串重复  eval(“‘#’* 10”)<br>将字符串转换成列表  eval(“[1,2,3,4]”)<br>将字符串转换成字典 <code>eval(&quot;{&#39;name&#39;:&#39;xiaoming&#39;, &#39;age&#39;:18}&quot;)</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 混合计算加减乘除</span></span><br><span class="line">input_str = input(<span class="string">"输入一个算术题"</span>)</span><br><span class="line">print(eval(input_str))</span><br></pre></td></tr></table></figure><p>输入：<br>输入一个算术题3*(8+4)<br>36</p><p>开发：不要滥用eval 直接转换input的结果</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>50.文件/目录的管理</title>
      <link href="/2019/08/07/50-%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%A1%E7%90%86/"/>
      <url>/2019/08/07/50-%E6%96%87%E4%BB%B6-%E7%9B%AE%E5%BD%95%E7%9A%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="文件-目录的常用管理操作"><a href="#文件-目录的常用管理操作" class="headerlink" title="文件/目录的常用管理操作"></a>文件/目录的常用管理操作</h3><ul><li>在终端/文件浏览器 中可以执行常规的文件/目录管理操作，例如：<ul><li>创建、重命名、修改、改变路径、查看目录内容、….</li></ul></li><li>在Python中，如果希望通过程序实现上述功能，需要导入 os 模块</li></ul><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>01</td><td>rename</td><td>重命名文件</td><td>os.rename(源文件名，目标文件名)</td></tr><tr><td>02</td><td>remove</td><td>删除文件</td><td>os.remove(文件名)</td></tr></tbody></table><h4 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h4><table><thead><tr><th>序号</th><th>方法名</th><th>说明</th><th>示例</th></tr></thead><tbody><tr><td>01</td><td>lisdiir</td><td>目录列表</td><td>os.lisdir(目录名)</td></tr><tr><td>02</td><td>mkdir</td><td>创建目录</td><td>os.mkdir(目录名)</td></tr><tr><td>03</td><td>rmdir</td><td>删除目录</td><td>os.rmdir(目录名)</td></tr><tr><td>04</td><td>getcwd</td><td>获取当前目录</td><td>os.getcwd()</td></tr><tr><td>05</td><td>chdir</td><td>修改工作目录</td><td>os.chdir(目标目录)</td></tr><tr><td>06</td><td>path.isdir</td><td>判断是否是文件</td><td>os.path.isdir(文件路径)</td></tr></tbody></table><p>提示：文件或者目录操作都支持相对路径和绝对路径</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>49.文件操作</title>
      <link href="/2019/08/07/49-%E6%96%87%E4%BB%B6/"/>
      <url>/2019/08/07/49-%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="文件操作的套路"><a href="#文件操作的套路" class="headerlink" title="文件操作的套路"></a>文件操作的套路</h4><p>在计算机中要操作文件的套路非常固定，一共包含三个步骤：</p><ol><li>打开文件</li><li>读、写文件<ul><li>读 将文件内容读入内存</li><li>写 将文件内容写入文件</li></ul></li><li>关闭文件</li></ol><h4 id="操作文件的函数-方法"><a href="#操作文件的函数-方法" class="headerlink" title="操作文件的函数/方法"></a>操作文件的函数/方法</h4><ul><li>在Python中操作文件需要记住1个函数和3个方法</li></ul><table><thead><tr><th>序号</th><th>函数/方法</th><th>说明</th></tr></thead><tbody><tr><td>01</td><td>open</td><td>打开文件，并且返回文件操作对象</td></tr><tr><td>02</td><td>read</td><td>将文件内容读取到内存</td></tr><tr><td>03</td><td>write</td><td>将指定内容写入文件</td></tr><tr><td>04</td><td>close</td><td>关闭文件</td></tr></tbody></table><ul><li>open 负责打开文件，并且返回文件对象</li><li>read/write/close 三个方法都需要通过文件对象来调用</li></ul><h4 id="read方法——读取文件"><a href="#read方法——读取文件" class="headerlink" title="read方法——读取文件"></a>read方法——读取文件</h4><ul><li>open函数的第一个参数是要打开的文件名（文件名区分大小写）<ul><li>如果文件存在，返回文件操作对象</li><li>如果文件不存在，会抛出异常</li></ul></li><li>read方法可以一次性读入并返回文件的所有内容</li><li>close方法负责关闭文件<ul><li>如果忘记关闭文件，会造成系统资源消耗，而且会影响到后续对文件的访问</li></ul></li><li>注意：方法执行后，会把文件指针移动到文件的末尾</li></ul><p>提示：</p><ul><li>在开发中，通常会先编写打开和关闭代码，再编写中间对文件的读/写操作！</li></ul><h4 id="打开文件的方式"><a href="#打开文件的方式" class="headerlink" title="打开文件的方式"></a>打开文件的方式</h4><ul><li>open函数默认以只读方式打开文件，并且返回文件对象</li></ul><p><strong>语法如下：</strong><br><code>f = open(&quot;文件名&quot;, &quot;访问方式&quot;)</code></p><table><thead><tr><th>访问方式</th><th>说明</th></tr></thead><tbody><tr><td>r</td><td>以只读方式打开文件。文件的指针将会放在文件的开通，这是默认模式。如果文件不存在，抛出异常</td></tr><tr><td>w</td><td>以只写方式打开。如果该文件存在会被覆盖。如果不存在，创建新文件</td></tr><tr><td>a</td><td>以追加方式打开文件。如果该文件已经存在，文件指针将会放在文件的结尾。如果文件不存在，创建新文件进行写入</td></tr><tr><td>r+</td><td>以读写方式打开文件。文件的指针将会放在文件的开头。如果文件不存在，抛出异常</td></tr><tr><td>w+</td><td>以读写方式打开文件。如果文件存在会被覆盖。如果文件不存在，创建新文件</td></tr><tr><td>a+</td><td>以读写方式打开文件。如果文件已存在，文件指针将会放在文件的结尾。如果文件不存在，创建新的文件进行写入</td></tr></tbody></table><p>提示：</p><ul><li>频繁的移动文件指针，会影响文件的读写效率，开发中更多的时候会以只读、只写的方式来操作文件</li></ul><h4 id="按行读取文件内容"><a href="#按行读取文件内容" class="headerlink" title="按行读取文件内容"></a>按行读取文件内容</h4><ul><li>read 方法默认会把文件的所有内容一次性读取到内存</li><li>如果文件太大，对内存的占用会非常严重</li></ul><p><strong>readline方法</strong></p><ul><li><code>readline</code>方法可以一次读取一行内容</li><li>方法执行后，会把文件指针移动到下一行，准备再次读取</li></ul><p><strong>读取大文件的正确姿势</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">file = open(<span class="string">"readme"</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 读取一行内容</span></span><br><span class="line">    text = file.readline()</span><br><span class="line">    <span class="comment"># 判断是否读到内容</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每读取一行的末尾已经有了一个'\n'</span></span><br><span class="line">    print(text, end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">file.close()</span><br></pre></td></tr></table></figure><h4 id="文件读写案例——复制文件"><a href="#文件读写案例——复制文件" class="headerlink" title="文件读写案例——复制文件"></a>文件读写案例——复制文件</h4><p>用代码的方式，来实现文件复制过程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.打开</span></span><br><span class="line">file_read = open(<span class="string">"readme"</span>)</span><br><span class="line">file_write = open(<span class="string">"reanme_copy"</span>, <span class="string">"w"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2,读，写</span></span><br><span class="line"><span class="comment"># 小文件</span></span><br><span class="line"><span class="comment"># text = file_read.read()</span></span><br><span class="line"><span class="comment"># 小文件</span></span><br><span class="line"><span class="comment"># file_write.write(text)</span></span><br><span class="line"><span class="comment"># 大文件</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    text = file_read.readline()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> text:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="comment"># 大文件</span></span><br><span class="line">    file_write.write(text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3,关闭</span></span><br><span class="line">file_write.close()</span><br><span class="line">file_read.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>48.包</title>
      <link href="/2019/08/07/48-%E5%8C%85/"/>
      <url>/2019/08/07/48-%E5%8C%85/</url>
      
        <content type="html"><![CDATA[<h3 id="包"><a href="#包" class="headerlink" title="包"></a>包</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ul><li>包是一个包含多个模块的特殊目录</li><li>目录下有一个特殊文件<code>__init__.py</code></li><li>包名的命名方式和变量名一致，小写字母+<code>_</code><br>好处<br>使用<code>import 包名</code>可以一次性导入包中所有的模块</li></ul><p><strong><code>__init__.py</code></strong></p><p>要在外界使用包中的模块，需要在<code>__init__.py</code>中指定对外界提供的模块列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从当前目录 导入 模块列表</span></span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> xxx模块</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> xx模块</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个py文件就是一个模块</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>47.模块</title>
      <link href="/2019/08/07/47-%E6%A8%A1%E5%9D%97/"/>
      <url>/2019/08/07/47-%E6%A8%A1%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><h4 id="模块的概念"><a href="#模块的概念" class="headerlink" title="模块的概念"></a>模块的概念</h4><p><strong><em>模块是Python程序构架的一个核心概念</em></strong></p><ul><li>每一个扩展名 py 结尾 的Python源文件都是一个模块</li><li>模块名同样也是一个标识符，需要符合标识符的命名规则</li><li>在模块中定义个全局变量、函数、类都是提供给外界直接使用的工具</li><li>模块就好比是工具包，想要使用这个工具包中的工具，就需要先导入这个模块<br>import sys<br>sys.pyth<br>可以显示搜索路径</li></ul><h4 id="模块的两种导入方式"><a href="#模块的两种导入方式" class="headerlink" title="模块的两种导入方式"></a>模块的两种导入方式</h4><p><strong>1）import 导入</strong><br><code>import 模块名1，模块名2</code><br>提示：在导入模块时，每个导入应该独占一行</p><pre><code>import 模块名1import 模块名2</code></pre><ul><li>导入之后<ul><li>通过 模块名. 使用模块提供的工具——全局变量、函数、类</li></ul></li></ul><p><strong>使用as指定模块的别名</strong></p><ul><li>如果模块名字太长，可以使用<code>import 模块名词 as 别名</code><br>模块别名应该符合大驼峰命名法</li></ul><p><strong>2）from…import 导入</strong></p><ul><li>如果如果希望从某一个模块中，导入部分工具，就可以使用<code>from...import</code>的方式</li><li>import 模块名 是一次性把模块中所有工具全部导入，并且通过模块/别名访问</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从模块中导入某一工具</span></span><br><span class="line">form 模块名<span class="number">1</span> <span class="keyword">import</span> 工具名</span><br></pre></td></tr></table></figure><ul><li>导入之后<ul><li>不需要通过 <code>模块名.</code></li><li>可以直接使用模块提供的工具——全局变量、函数、类</li></ul></li></ul><p><strong>注意</strong><br><strong>如果两个模块，存在同名的函数，那么后导入模块的函数会覆盖掉先导入的函数</strong></p><ul><li>开发时，import 代码应该统一写在代码顶部，更容易及时发现冲突（灰色）</li><li>一旦发现冲突，可以使用as关键字给其中一个工具起一个别名</li></ul><h4 id="原则——每一个文件都应该可以被导入的"><a href="#原则——每一个文件都应该可以被导入的" class="headerlink" title="原则——每一个文件都应该可以被导入的"></a>原则——每一个文件都应该可以被导入的</h4><ul><li>一个独立的Python文件就是一个模块</li><li>在导入文件时，文件中所有没有任何缩进的代码都会被执行一遍</li></ul><p><strong>实际开发场景</strong></p><ul><li>在实际开发中，每一个模块都是独立开发的，大多有专人负责</li><li>开发人员通常会在模块下方增加一些测试代码<ul><li>仅在模块内使用，而被导入到其他文件中不需要执行</li></ul></li></ul><p><strong><code>__name__</code>属性</strong></p><p><code>__name__</code>属性可以做到，测试模块的代码只在测试情况下被运行，而在被导入时不被执行！</p><ul><li><code>__name__</code>时Python的一个内置属性，记录着一个字符串</li><li>如果是被其他文件导入的 <code>__name__</code>就是模块名</li><li>如果是当前执行的程序，<code>__name__</code>就是<code>__mian__</code><br>在很多Python文件爱你中都会看到以下格式的代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="comment"># 定义全局变量</span></span><br><span class="line"><span class="comment"># 定义类</span></span><br><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在代码的最下方</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">#....</span></span><br><span class="line"><span class="function"><span class="title">pass</span></span></span><br><span class="line"><span class="function"># 根据 <span class="title">__name__</span>判断是否执行下方代码</span></span><br><span class="line">if __name__ == "__main__":</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>form imp import reload<br>realad(xx)<br>重新导入</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模块 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>46.异常</title>
      <link href="/2019/08/06/46-%E5%BC%82%E5%B8%B8/"/>
      <url>/2019/08/06/46-%E5%BC%82%E5%B8%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="异常的概念"><a href="#异常的概念" class="headerlink" title="异常的概念"></a>异常的概念</h3><ul><li>程序在运行时，如果Python解释器遇到一个错误，会停止程序的执行，并且提示一些错误信息，这就是异常</li><li>程序停止执行并且提示错误信息这个动作，我们通常称之为：抛出(raise)异常</li></ul><p>程序开发时，很难讲所有的特殊情况面面俱到，通过异常捕获可以针对突发事情做机场的处理，从而保证程序的稳定性和健壮性</p><h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><h4 id="简单的捕获异常语法"><a href="#简单的捕获异常语法" class="headerlink" title="简单的捕获异常语法"></a>简单的捕获异常语法</h4><p>在程序开发中，如果对某些代码的执行不能确定是否正确，可以增加try 来捕获异常<br>捕获异常最简单的语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h4 id="错误类型捕获"><a href="#错误类型捕获" class="headerlink" title="错误类型捕获"></a>错误类型捕获</h4><ul><li><p>在程序执行时，可能会遇到不同类型的异常，并且需要针对不同类型的异常，做出不同的相应，这个时候，就需要捕获错误类型了</p></li><li><p>语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 尝试执行的代码</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line"><span class="comment"># 针对错误的类型1，对应的代码处理</span></span><br><span class="line">pss</span><br><span class="line"><span class="keyword">except</span> （错误类型<span class="number">2</span>，错误类型<span class="number">3</span>）:</span><br><span class="line"><span class="comment"># 针对错误类型2和3，对应的代码处理</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">print(<span class="string">"未知错误%s"</span> % result)</span><br></pre></td></tr></table></figure></li><li><p>当Python解释器抛出异常时，最后一行错误信息的第一个单词，就是错误类型<br>捕获未知错误<br>在开发时，要预判到所有可能出现的错误，还是有一点难度的<br>如果希望程序无论出现任何错误，都不因为Python解释器抛出异常而终止，可以增加一个exce<br>语法如下：</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exceptExceptio  <span class="keyword">as</span> resolt:</span><br><span class="line">    print(<span class="string">"未知错%as"</span> % resule)</span><br></pre></td></tr></table></figure><h4 id="完整异常捕获语法"><a href="#完整异常捕获语法" class="headerlink" title="完整异常捕获语法"></a>完整异常捕获语法</h4><ul><li>在实际开发中，为了能够处理复杂的异常情况，完整的异常语法如下：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="comment"># 尝试执行的代码</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 错误类型<span class="number">1</span>:</span><br><span class="line"><span class="comment"># 针对错误的类型1，对应的代码处理</span></span><br><span class="line">pss</span><br><span class="line"><span class="keyword">except</span> （错误类型<span class="number">2</span>，错误类型<span class="number">3</span>）:</span><br><span class="line"><span class="comment"># 针对错误类型2和3，对应的代码处理</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">print(<span class="string">"未知错误%s"</span> % result)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 没有错误才会执行的代码</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="comment"># 无论是否有异常，都会执行的代码</span></span><br><span class="line">print(<span class="string">"无论是否有异常，都会执行的代码"</span>)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">- <span class="keyword">else</span> 只有在没有异常时才会执行的代码</span><br><span class="line">- finall 无论是否有异常，都会执行的代码</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 异常的传递</span></span><br><span class="line">- 异常的传递——当 函数/方法执行出现异常，会将异常传递给 函数/方法的调用一方</span><br><span class="line">- 如果传递到主程序，任然没有异常处理，程序才会被终止</span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">- 在研发中，可以在主函数中增加异常捕获</span><br><span class="line">- 而在主函数中调用其他函数，只要出现异常，都会传递到主函数的异常捕获中</span><br><span class="line">- 这样就不需要再代码中，增加大量的异常捕获，能够保证代码的整洁</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 抛出raise异常</span></span><br><span class="line"><span class="comment">##### 应用场景</span></span><br><span class="line">- 在开发中，除了代码执行出错Python解释器会抛出异常之外</span><br><span class="line">- 还可以根据程序特有的业务需求主动抛出异常</span><br><span class="line">**示例**</span><br><span class="line"> - 提示用户输入密码，如果长度少于<span class="number">8</span>，抛出异常</span><br><span class="line"> - 可以抛出异常，有其他需要处理的函数捕获异常</span><br><span class="line"> </span><br><span class="line"><span class="comment">#### 抛出异常</span></span><br><span class="line">- Python中提供了一个Exception异常类</span><br><span class="line">- 在开发时，如果满足特定业务需求时，希望抛出异常，可以：</span><br><span class="line"> <span class="number">1.</span> 创建一个Exception的对象</span><br><span class="line"> <span class="number">2.</span> 使用<span class="keyword">raise</span>关键字抛出异常对象</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_password</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 1.提示用户输入密码</span></span><br><span class="line">    pwd = input(<span class="string">"请输入密码："</span>)</span><br><span class="line">    <span class="comment"># 2.判断密码长度 &gt;= 8,返回用户输入的密码</span></span><br><span class="line">    <span class="keyword">if</span> len(pwd) &gt;= <span class="number">8</span>:</span><br><span class="line">        <span class="keyword">return</span> pwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3.如果 &lt; 8 主动抛出异常</span></span><br><span class="line">    print(<span class="string">"主动抛出异常"</span>)</span><br><span class="line">    <span class="comment"># 1》创建异常对象</span></span><br><span class="line">    ex = Exception(<span class="string">"密码长度不够"</span>)</span><br><span class="line">    <span class="comment"># 2》主动抛出异常</span></span><br><span class="line">    <span class="keyword">raise</span> ex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提示用户输入密码</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(input_password())</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> result:</span><br><span class="line">    print(result)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异常 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>45.单例</title>
      <link href="/2019/08/06/45-%E5%8D%95%E4%BE%8B/"/>
      <url>/2019/08/06/45-%E5%8D%95%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="1-单例设计模式"><a href="#1-单例设计模式" class="headerlink" title="1. 单例设计模式"></a>1. 单例设计模式</h4><ul><li>设计模式<ul><li>设计模式是前人工作的总结和提炼，通常，被人们广泛流传的设计模式都是针对某一特定问题的成熟解决方案</li><li>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性</li></ul></li><li>单例设计模式</li><li>目的——让类创建的对象，在系统中只有唯一一个实例</li><li>每一次执行<code>类名()</code>返回的对象，内存地址是相同的</li></ul><h4 id="2-new-方法"><a href="#2-new-方法" class="headerlink" title="2. __new__方法"></a>2. <code>__new__</code>方法</h4><ul><li>使用 类名() 创建对象时，Python的解释器首先会调用 <code>__new__</code>方法为对象分配空间</li><li><code>__new__</code>是一个由object积累提供的内置静态方法，主要作用有两个：<ul><li>1 . 在内存中中为对象分配空间</li><li>2 . 返回对象的引用</li></ul></li><li>Python的解释器获得对象的引用后，将引用作为第一个参数，传递给 <code>__new__</code>方法</li></ul><p><em>重写 <code>__new__</code>方法的代码非常固定</em></p><ul><li>重写 <code>__new__</code>方法一定要<code>return super. __new__(cls)</code></li><li>否则Python的解释器得不到分配了空间的对象引用，就不会调用对象的初始化方法</li><li>注意： <code>__new__</code>是一个静态方法，在调用时需要主动传递 cls 参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 创建对象时，new方法会被自动调用</span></span><br><span class="line">        print(<span class="string">"创建对象，分配空间"</span>)</span><br><span class="line">        <span class="comment"># 为对象分配空间，返回对象的引用</span></span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"初始化"</span>)</span><br><span class="line"></span><br><span class="line">music = MusicPlayer()</span><br><span class="line">print(music)</span><br></pre></td></tr></table></figure><h4 id="3-Python中的单例"><a href="#3-Python中的单例" class="headerlink" title="3.Python中的单例"></a>3.Python中的单例</h4><ul><li>单例——让类创建的对象，在系统中只有唯一的一个实例<ol><li>定义一个类属性，初始值时None，用于记录单例对象的引用</li><li>重写<code>__new__</code>方法</li><li>如果类属性 is None ，调用父类方法分配空间，并在类属性中记录结果</li><li>返回类属性中记录的对象停用</li></ol></li></ul><h4 id="只执行一次初始化工作"><a href="#只执行一次初始化工作" class="headerlink" title="只执行一次初始化工作"></a>只执行一次初始化工作</h4><p>在每次只使用 类名() 创建对象时，Python的解释器都会自动调用两个方法：<br> <code>__new__</code>分配空间<br>  <code>__init__</code>对象初始化</p><p>解决办法：</p><ol><li>定义一个类属性 init_flag 标记是否执行过初始化动作，初始值为False</li><li>在 <code>__init__</code>方法中，判断init_flag，如果为False就执行初始化动作</li><li>然后将init_flag设置为 True</li><li>这样，这次自动调用  <code>__init__</code>方法时，初始化动作就不会再次执行了</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MusicPlayer</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录第一个被创建对象的引用</span></span><br><span class="line">    instance = <span class="literal">None</span></span><br><span class="line">    <span class="comment"># 记录是否执行过初始化动作</span></span><br><span class="line">    init_flag = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        <span class="comment"># 1.判断类属性是否是空对象</span></span><br><span class="line">        <span class="keyword">if</span> cls.instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># 2.调用父类的方法，为第一个对象分配空间</span></span><br><span class="line">            cls.instance = super().__new__(cls)</span><br><span class="line">        <span class="comment"># 3.返回类属性保存的对象引用</span></span><br><span class="line">        <span class="keyword">return</span> cls.instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 1.判断是否执行过初始化动作</span></span><br><span class="line">        <span class="keyword">if</span> MusicPlayer.init_flag:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 2.执行初始化动作</span></span><br><span class="line">        print(<span class="string">"aaaaaaaa"</span>)</span><br><span class="line">        <span class="comment"># 3.修改类属性标志</span></span><br><span class="line">        MusicPlayer.init_flag = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多个对象</span></span><br><span class="line">player1 = MusicPlayer()</span><br><span class="line">print(player1)</span><br><span class="line"></span><br><span class="line">player2 = MusicPlayer()</span><br><span class="line">print(player2)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>44.静态方法</title>
      <link href="/2019/08/06/44-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/06/44-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><ul><li>在开发时，如果需要在类中封装一个方法，这个方法：<ul><li>既不需要访问实例属性或者调用实例方法</li><li>也不需要访问类属性或者调用类方法</li></ul></li><li>这个时候，可以把这个方法封装成一个静态方法</li></ul><p>语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 静态方法名<span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>静态方法需要用修饰器<code>@staticmethod</code> 来标识，告诉解释器这是一个静态方法</li><li>通过 类名. 调用静态方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(object)</span>:</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span>         <span class="comment"># 没有self了</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 不访问实例属性/类属性</span></span><br><span class="line">        print(<span class="string">"跑"</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过类名.调用静态方法--不需要创建对象</span></span><br><span class="line">Dog.run()</span><br></pre></td></tr></table></figure><ol><li>实例方法——方法内部需要访问实例属性<ul><li>实例方法内部可以使用 类名. 访问类属性</li></ul></li><li>类方法——方法内部只需要访问类属性</li><li>静态方法——方法内部，不需要访问实例属性和类属性</li></ol><p>如果方法内部即需要访问实例属性，有需要访问类属性，应该定义成实例方法，因为类只有一个，在实例方法内部可以使用 类名. 访问类属性</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>43.类方法</title>
      <link href="/2019/08/06/43-%E7%B1%BB%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/06/43-%E7%B1%BB%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h3><ul><li>类属性就是针对类对象定义的属性<ul><li>使用赋值语句在 class 关键字下方可以定义类属性</li><li>类属性用于记录与这个类相关的特征</li></ul></li><li>类方法就是针对类对象定义的方法<ul><li>在类方法内部可以直接访问类属性或者调用其他的类方法</li></ul></li></ul><p><strong>语法如下</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 类方法名<span class="params">(cls)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>类方法需要用修饰器@classmethod来标识，告诉解释器这是一个类方法</li><li>类方法的第一个参数应该是 cls<ul><li>由哪一个类调用的方法，方法内的 cls 就是哪一个类的引用</li><li>这个参数和实例方法的第一个参数 self 类似</li><li>提示 使用其他名称也可以，不过习惯使用cls</li></ul></li><li>通过 类名. 调用类方法，调用方法时，不需要传递cls 参数</li><li>在方法内部<ul><li>也可以通过 cls. 访问类的属性</li><li>也可以通过 cls. 调用其他的类方法</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 使用赋值语句定义类属性，记录所有工具对象的数量</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">show_tool_count</span><span class="params">(cls)</span>:</span></span><br><span class="line"><span class="comment"># 在类方法内部，可以直接使用cls访问雷属性或者调用类方法</span></span><br><span class="line">        print(<span class="string">"工具对象的数量%d"</span> % cls.count)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 让类属性的值加一</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tool1 = Tool(<span class="string">"aa"</span>)</span><br><span class="line">tool2 = Tool(<span class="string">"bb"</span>)</span><br><span class="line">tool3 = Tool(<span class="string">"cc"</span>)</span><br><span class="line">Tool.show_tool_count()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>42.类属性</title>
      <link href="/2019/08/06/42-%E7%B1%BB%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/08/06/42-%E7%B1%BB%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h4 id="1-术语——实例"><a href="#1-术语——实例" class="headerlink" title="1,  术语——实例"></a>1,  术语——实例</h4><ol><li>使用面向对象开发，第一步是设计类</li><li>使用类名()创建对象，创建对象的动作有两步：<ol><li>在内存中为对象分配空间</li><li>调用初始化方法<code>__init__</code>为对象初始化</li></ol></li><li>对象创建后，内存中就有了一个对象的实实在在的存在——实例</li></ol><p>因此，通常也会把：</p><ol><li>创建出来的对象叫做类的实例</li><li>创建对象的动作叫做实例化</li><li>对象的属性叫做实例属性</li><li>对象的调用方法叫做实例方法</li></ol><p>在程序执行时：</p><ol><li>对象各自拥有自己的实例属性</li><li>调用对象方法，可以通过<code>self.</code><ul><li>访问自己的属性</li><li>调用自己的方法</li></ul></li></ol><p>结论</p><ul><li>每一个对象都有自己独立的内存空间，保存各自不同的属性</li><li>多个对象的方法，在内存中只有一份，在调用方法时，需要把对象的引用传递到方法内部</li></ul><h4 id="2，类是一个特殊的对象"><a href="#2，类是一个特殊的对象" class="headerlink" title="2，类是一个特殊的对象"></a>2，类是一个特殊的对象</h4><p>Python中一切皆对象：<br><code>class AAA：</code>定义的类属于类对象<br><code>obj1 = AAA()</code>属于实例对象</p><ul><li>在程序运行时，类同样会被加载到内存</li><li>在Python中，类是一个特殊的对象——类对象</li><li>在程序运行时，类对象在内存中只有一份，使用一个类可以创造出很多个对象实例</li><li>除了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法<br>1，类属性<br>2，类方法</li><li>通过 类名. 的方式可以访问类的属性或者调用的方法</li></ul><h4 id="3，类属性和实例属性"><a href="#3，类属性和实例属性" class="headerlink" title="3，类属性和实例属性"></a>3，类属性和实例属性</h4><h5 id="概念和使用"><a href="#概念和使用" class="headerlink" title="概念和使用"></a>概念和使用</h5><ul><li>类属性就是给类对象中定义的属性</li><li>通常用来记录与这个类相关的特征</li><li>类属性不会用于记录具体对象的特征</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tool</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 使用赋值语句定义类属性，记录所有工具对象的数量</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 让类属性的值加一</span></span><br><span class="line">        Tool.count += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tool1 = Tool(<span class="string">"aa"</span>)</span><br><span class="line">tool2 = Tool(<span class="string">"bb"</span>)</span><br><span class="line">tool3 = Tool(<span class="string">"cc"</span>)</span><br><span class="line">print(Tool.count)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>41.多态</title>
      <link href="/2019/08/06/41-%E5%A4%9A%E6%80%81/"/>
      <url>/2019/08/06/41-%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>面向对象三大特性</p><ol><li>封装，根据职责将属性和方法封装到一个抽象的类中<pre><code>定义类的准则</code></pre></li><li>继承，实现代码的重用，相同的代码不需要重复的编写<pre><code>设计类的技巧子类针对自己特有的需求，编写特定的代码</code></pre></li><li>多态，不同的子类对象调用相同的父类方法，产生不同的执行结果<pre><code>多态可以增加代码的灵活度以继承和重写父类方法为前提是调用方法的技巧，不会影响到类的内部设计</code></pre></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s普通玩"</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XiaoTianDog</span><span class="params">(Dog)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s天上玩"</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">game_with_dog</span><span class="params">(self, dog)</span>:</span></span><br><span class="line">        print(<span class="string">"%s和狗%s玩"</span> % (self.name, dog.name))</span><br><span class="line">        dog.game()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dd = Dog(<span class="string">"狗"</span>)</span><br><span class="line">d = XiaoTianDog(<span class="string">"哮天犬"</span>)</span><br><span class="line">m = Person(<span class="string">"张三"</span>)</span><br><span class="line">m.game_with_dog(dd)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>40.多继承，super</title>
      <link href="/2019/08/06/40-%E5%A4%9A%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/08/06/40-%E5%A4%9A%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>子类可以拥有多个父类，并且具有所有父类的属性和方法<br>语法</p><pre><code>class 子类名(父类名1，父类名2...)    pass</code></pre><h4 id="多继承的使用注意事项"><a href="#多继承的使用注意事项" class="headerlink" title="多继承的使用注意事项"></a>多继承的使用注意事项</h4><ul><li>问题：如果不同的父类存在同名的方法，子类对象在调用方法时，会调用哪一个父类中的方法呢？<br>开发时，应该尽量避免这种容易产生混淆的情况！——如果父类之间存在同名的属性或方法，应该尽量避免使用多继承</li></ul><pre><code class="bash">解决：使用 最底下的类名.__mro__ 方法查看继承调用的先后顺序继承不是复制，只是指向了那个位置1，super().__init__相对于类名.__init__，在单继承上用法基本无差2，但在多继承上有区别，super方法能保证每个父类方法只会执行一次，而使用雷鸣的方法会导致方法被执行多次，具体看前面的输出结果3，多继承时，使用super方法，对父类传参数，应该是由于Python中的super的算法导致的原因，必须把参数全部传递，否则会报错4，单继承时，使用super方法，则不能全部传递，只能穿父类方法所需的参数，否则会报错5，多继承时，相对于使用类名.__init__方法，要把每个父类全部写一遍，而使用super方法，只需写一句话执行全部父类的方法，这也是为何多继承需要全部传参数的原因</code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>39.父类的私有属性和私有方法</title>
      <link href="/2019/08/05/39-%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/05/39-%E7%88%B6%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="父类的私有属性和私有方法"><a href="#父类的私有属性和私有方法" class="headerlink" title="父类的私有属性和私有方法"></a>父类的私有属性和私有方法</h4><ol><li>子类对象不能在自己的方法内部，直接访问父类的私有属性或私有方法</li><li>子类对象可以通过父类的共有方法间接访问到私有属性或私有方法<ul><li>私有属性、方法 是对象的隐私，不对外公开，外界以及子类都不能直接访问</li><li>私有属性、方法通常用于做一些内部的事情</li></ul></li></ol><h4 id="python-的私有化："><a href="#python-的私有化：" class="headerlink" title="python 的私有化："></a>python 的私有化：</h4><ol><li><code>xx</code> :公有变量</li><li><code>_x</code>:单前置下划线，私有化属性或方法，禁止通过form modules import * 导入，但是类和对象可以访问</li><li><code>__xx</code> ：双前置下划线，避免与子类中的属性名冲突，无法在外部直接访问（名字重整所以访问不到），类对象和子类不能访问</li><li><code>__xx__</code>：双前后下划线，用户名字空间的魔法对象或属性。例如：<strong>init，</strong>尽量不要自定义这种形式的。</li><li><code>xx_</code>：单后置下划线，用于避免与Python关键词的冲突</li></ol><p>实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.num1 = <span class="number">100</span></span><br><span class="line">        self.__num2 = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"私有方法 %d % d"</span> % (self.num1, self.__num2))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"父类的公有方法%d"</span> % self.__num2)</span><br><span class="line">        self.__test()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 1.在子类的对象方法中，不能访问父类的私有属性</span></span><br><span class="line">        <span class="comment"># print("访问父类的私有属性 %d" % self.__num2)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 2.不能调用父类的私有方法</span></span><br><span class="line">        <span class="comment"># self.__test()</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 3.访问父类的公有属性</span></span><br><span class="line">        print(<span class="string">"子类方法 %d "</span> % self.num1)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 4.调用父类的公有方法</span></span><br><span class="line">        self.test()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个子类对象</span></span><br><span class="line">b = B()</span><br><span class="line">print(b)</span><br><span class="line">b.demo()</span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在外界不能直接访问对象的私有属性/调用私有方法</span></span><br><span class="line"><span class="comment"># print(b.__num2)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>38.继承</title>
      <link href="/2019/08/05/38-%E7%BB%A7%E6%89%BF/"/>
      <url>/2019/08/05/38-%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>面向对象三大特征</p><ul><li>封装，根据职责将属性和方法封装到一个抽象的类中</li><li>继承，实现代码的重用，相同的代码不需要重复编写</li><li>多态，不同的对象调用相同的方法，产生不同的执行结果，增加代码的灵活度</li><li>单继承<br>继承的概念：子类拥有父类的所有方法和属性</li></ul><h4 id="1，继承语法"><a href="#1，继承语法" class="headerlink" title="1，继承语法"></a>1，继承语法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名<span class="params">(父类名)</span>：</span></span><br><span class="line"><span class="class">    <span class="title">pass</span></span></span><br></pre></td></tr></table></figure><p>子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发<br>子类中应该根据职责，封装子类特有的属性和方法</p><h4 id="2，继承的传递性"><a href="#2，继承的传递性" class="headerlink" title="2，继承的传递性"></a>2，继承的传递性</h4><ul><li>C类从B类继承，B类有从A类继承，那么C类就具有B类和A类的所有属性和方法</li><li>子类拥有父类以及父类的父类中封装的所有属性和方法</li></ul><h4 id="3，方法的重写"><a href="#3，方法的重写" class="headerlink" title="3，方法的重写"></a>3，方法的重写</h4><ul><li>子类拥有父类的所有方法和属性</li><li>子类继承自父类，可以直接享受父类中已经封装好的方法，不需要再次开发</li></ul><p><strong>应用场景</strong></p><ul><li>当父类的方法不能满足子类需求时，可以对方法进行重写（override）</li></ul><p><strong>重写父类的方法有两种情况</strong></p><ol><li>覆盖父类的方法</li><li>对父类方法进行扩展</li></ol><p><strong>1）覆盖父类的方法</strong></p><ul><li>如果在开发中，父类的方法实现和子类的方法实现完全不同，就可以使用覆盖的方式，在子类中重新编写父类的方法实现</li></ul><p><em>具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现</em></p><p>重写之后，在运行时，只会调用子类中重写的方法，而不会调用父类封装的方法</p><p><strong>2）对父类方法进行扩展</strong></p><ul><li>如果在开发中，子类的方法实现方法中，包含父类的方法实现<ul><li>父类原本封装的方法实现时子类方法的一部分</li></ul></li><li>就可以使用扩展的方式<ol><li>在子类中重写父类的方法</li><li>在需要的位置使用<code>super().父类方法</code>来调用父类方法的执行</li><li>代码其他的位置针对子类的需求，编写子类特有的代码实现</li></ol></li></ul><p><strong>关于super</strong></p><ul><li>在Python中super是一个特殊的类</li><li>super()就是使用super类创建出来的对象</li><li>最常用的场景就是在重写父类时，调用在父类中封装的方法实现</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>37.私有属性和私有方法</title>
      <link href="/2019/08/05/37-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/05/37-%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7%E5%92%8C%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="私有属性和私有方法"><a href="#私有属性和私有方法" class="headerlink" title="私有属性和私有方法"></a>私有属性和私有方法</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>在实际开发中，对象的某些属性或方法可能只希望在对象内部被使用，而不希望在外部被访问到</li><li>私有属性就是对象不希望公开的属性</li><li>私有方法就是对象不希望公开的方法</li></ul><h4 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h4><ul><li>在定义属性或方法时，在属性名或者方法名前面增加<strong>两个下划线</strong>，定义的就是私有属性或方法</li></ul><p><strong><em>注意：</em></strong><br><strong>私有属性在外界不能被直接访问</strong><br><strong>私有方法同样不允许在外界访问</strong><br><strong>在对象的方法内部，是可以访问对象的私有属性的</strong></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>36.面向对象-封装</title>
      <link href="/2019/08/05/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/"/>
      <url>/2019/08/05/36-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%B0%81%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><ol><li>封装时面向对象编程的一大特点</li><li>面向对象编程的第一步——将属性和方法封装到一个抽象的类中</li><li>外界使用类创建对象，然后让对象调用方法</li><li>对象方法的细节都被封装在类的内部</li></ol><p><strong>案例提示：</strong></p><ol><li>在对象方法内部，是可以可以直接访问对象的属性的</li><li>同一个类创建的多个对象之间，属性互不干预</li><li>一个对象的属性，可以是另一个类创建的对象</li></ol><p><strong>被使用的类，通常应该先开发</strong><br><strong>定义没有初始值的属性</strong><br><strong>在定义属性时，如果不知道设置什么初始值，可以设置为None</strong></p><ul><li>None关键字表示什么都没有</li><li>表示一个空对象，没有方法和属性，是一个特殊的常量</li><li>可以将None赋值给任何一个变量</li></ul><h3 id="身份运算符"><a href="#身份运算符" class="headerlink" title="身份运算符"></a>身份运算符</h3><p>身份运算符用于比较两个对象的内存地址是否一致——是否是同一个对象的引用</p><ul><li>在Python中针对None比较时，建议使用<code>is</code>判断</li></ul><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>用于判断两个标识符是不是引用同一个对象</td><td>x is y, 类似 id(x) == id(y)</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用不同对象</td><td>x is not y, 类似 id(x) !=id(y)</td></tr></tbody></table><p><strong>is 与==区别：</strong></p><ul><li>is 用于判断两个变量引用对象是否为同一个</li><li>==用于判断引用对象的值是否相等</li></ul><p>例子1：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, weight)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.weight = weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我的名字是%s，体重是 %.2f公斤"</span> % (self.name, self.weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s跑步"</span> % self.name)</span><br><span class="line">        self.weight -= <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"吃东西%s"</span> % self.name)</span><br><span class="line">        self.weight += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">xiaoming = Person(<span class="string">"小明"</span>, <span class="number">74.44</span>)</span><br><span class="line">xiaoming.run()</span><br><span class="line">xiaoming.eat()</span><br><span class="line"></span><br><span class="line">xiaomei = Person(<span class="string">"小美"</span>, <span class="number">45</span>)</span><br><span class="line">xiaomei.eat()</span><br><span class="line">xiaomei.run()</span><br><span class="line"></span><br><span class="line">print(xiaoming)</span><br><span class="line">print(xiaomei)</span><br><span class="line">print(xiaoming)</span><br></pre></td></tr></table></figure><p>例子2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HouseItem</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, area)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.area = area</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"[%s]占地  %.2f"</span> % (self.name, self. area)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, house_type, area)</span>:</span></span><br><span class="line">        self.house_type = house_type</span><br><span class="line">        self.area = area</span><br><span class="line">        <span class="comment"># 剩余面积</span></span><br><span class="line">        self.free_area = area</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 家具名词</span></span><br><span class="line">        self.item_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># python 能够自动将一对括号内部的代码连接在一起</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="string">"户型： %s\n总面积: %.2f[剩余:%.2f]\n家具:%s"</span></span><br><span class="line">                % (self.house_type, self.area,</span><br><span class="line">                   self.free_area, self.item_list))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        print(<span class="string">"要添加%s"</span> % item)</span><br><span class="line">        <span class="string">"""if里面变大于号的话，可以用return直接结束，然后不要else"""</span></span><br><span class="line">        <span class="keyword">if</span> item.area &lt; self.free_area:</span><br><span class="line">            self.free_area = self.free_area - item.area</span><br><span class="line">            self.item_list.append(item.name)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"空间不足，无法添加:%s"</span> % item.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">bed = HouseItem(<span class="string">"床"</span>, <span class="number">3</span>)</span><br><span class="line">chest = HouseItem(<span class="string">"衣柜"</span>, <span class="number">2</span>)</span><br><span class="line">table = HouseItem(<span class="string">"餐桌"</span>, <span class="number">1.3</span>)</span><br><span class="line">ball = HouseItem(<span class="string">"巨无霸"</span>, <span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">print(bed)</span><br><span class="line">print(chest)</span><br><span class="line">print(table)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建房子对象</span></span><br><span class="line">my_home = House(<span class="string">"两室一厅"</span>, <span class="number">60</span>)</span><br><span class="line">my_home.add_item(bed)</span><br><span class="line">my_home.add_item(chest)</span><br><span class="line">my_home.add_item(table)</span><br><span class="line">my_home.add_item(ball)</span><br><span class="line"></span><br><span class="line">print(my_home)</span><br></pre></td></tr></table></figure><p>例子3</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gun</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, model)</span>:</span></span><br><span class="line">        self.model = model</span><br><span class="line">        self.bullet_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_buller</span><span class="params">(self, count)</span>:</span></span><br><span class="line">        self.bullet_count += count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">shoot</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.bullet_count &lt;= <span class="number">0</span>:</span><br><span class="line">            print(<span class="string">"[%s]没有子弹了"</span> % self.model)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        self.bullet_count -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"%s 突突 [%d]"</span> % (self.model, self.bullet_count))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solder</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        <span class="comment"># 新兵没有枪</span></span><br><span class="line">        self.gun = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fire</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 身份运算符</span></span><br><span class="line">        <span class="comment"># if self.gun == None:</span></span><br><span class="line">        <span class="keyword">if</span> self.gun <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            print(<span class="string">"%s没有枪。。。"</span> % self.name)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        print(<span class="string">"冲%s"</span> % self.name)</span><br><span class="line">        self.gun.add_buller(<span class="number">50</span>)</span><br><span class="line">        self.gun.shoot()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ak47 = Gun(<span class="string">"ak47"</span>)</span><br><span class="line"></span><br><span class="line">xusanduo = Solder(<span class="string">"许三多"</span>)</span><br><span class="line">xusanduo.gun = ak47</span><br><span class="line">xusanduo.fire()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>35.面向对象-内置方法和属性</title>
      <link href="/2019/08/05/35-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/"/>
      <url>/2019/08/05/35-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95%E5%92%8C%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="内置方法和属性"><a href="#内置方法和属性" class="headerlink" title="内置方法和属性"></a>内置方法和属性</h3><table><thead><tr><th>序号</th><th>方法名</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td><code>__del__</code></td><td>方法</td><td>对象被从内存中销毁前，会被自动调用</td></tr><tr><td>02</td><td><code>__str__</code></td><td>方法</td><td>返回对象的描述信息，print函数输出使用</td></tr></tbody></table><p><strong>1.<code>__del__</code>方法</strong></p><ul><li><p><strong>在Python中</strong></p><ul><li>当使用 类名()创建对象时，为对象分配完空间后，自动调用<code>__init__</code>方法</li><li>当一个对象被从内存中销毁前，会自动调用<code>__del__</code>方法</li></ul></li><li><p><strong>应用场景</strong></p><ul><li><code>__del__</code>改造初始化方法，可以让创建对象更加灵活</li><li><code>__del__</code>如果希望在对象被销毁前，在做一些事，可以考虑一下<code>__del__</code>方法</li></ul></li><li><p><strong>生命周期</strong></p><ul><li>一个对象从调用 类名()创建，生命周期开始</li><li>一个对象的<code>__del__</code>方法一旦被调用，生命周期结束</li><li>在对象的生命周期内，可以访问对象属性或者让对象调用方法</li></ul></li></ul><p><strong>2.<code>__str__</code>方法</strong></p><ul><li>在Python中，使用print输出对象变量，默认情况下，会输出这个变量引用的对象是由哪一个类创建的对象，以及在内存在内存中的地址，（十六进制表示）</li><li>如果在开发中，希望使用print输出对象变量时，能够打印自定义的内容，就可以利用<code>__str__</code>这个内置方法了</li></ul><p><strong>注意</strong>：<code>__str__</code>方法必须返回一个字符串</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>34.面向对象-初始化方法</title>
      <link href="/2019/08/05/34-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/05/34-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<ul><li>在日常开发中，不推荐在类的外部给对象增加属性<ul><li>如果在运行时，没有找到属性，程序会报错</li></ul></li><li>对象应该包含有哪些属性，应该封装在类的内部</li></ul><h4 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h4><ul><li>当使用 类名() 创建对象时，会自动执行以下操作：<ol><li>为对象在内存中分配空间——创建对象</li><li>为对象的属性设置初始值——初始化方法（init）</li></ol></li><li>这个初始化方法就是（<code>__init__</code>）方法，<code>__init__</code>是对象的内置方法<br><code>__init__</code>方法时专门用来定义一个类具体有哪些属性的方法！</li></ul><h4 id="在初始化方法内部定义属性"><a href="#在初始化方法内部定义属性" class="headerlink" title="在初始化方法内部定义属性"></a>在初始化方法内部定义属性</h4><ul><li>在<code>__init__</code>方法内部使用 <code>self.属性名=属性的初始值</code>就可以定义属性</li><li>定义属性之后，再使用类创建的对象都会拥有该属性</li></ul><p>改造初始化方法——初始化的同时设置初始值<br>在开发中，如果希望在创建对象的同时，就设置对象的属性，可以对<code>__init__</code>方法 进行改造<br>把希望设置的属性值，定义成<code>__init__</code>方法的参数<br>在方法内部使用<code>self.属性=形参</code>就收外部传递的参数<br>在创建对象时，使用<code>类名(属性1，属性2...)</code>调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, new_name)</span>:</span></span><br><span class="line">        self.name = new_name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"%s嗝"</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类名()创建对象的时候，会自动调用初始化方法 __init__</span></span><br><span class="line">tom = Cat(<span class="string">"Tom"</span>)</span><br><span class="line">print(tom.name)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>33.面向对象-self</title>
      <link href="/2019/08/05/33-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-self/"/>
      <url>/2019/08/05/33-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-self/</url>
      
        <content type="html"><![CDATA[<p>self指调用方法的对象</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>32.面向对象-定义简单类</title>
      <link href="/2019/08/04/32-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%B1%BB/"/>
      <url>/2019/08/04/32-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%E5%AE%9A%E4%B9%89%E7%AE%80%E5%8D%95%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="定义简单的类"><a href="#定义简单的类" class="headerlink" title="定义简单的类"></a>定义简单的类</h3><p>面向对象是更大的封装，在一个类中封装多个方法，这样通过这个类创建出来的对象，就可以直接调用这些方法了</p><h4 id="定义只包含方法的类"><a href="#定义只包含方法的类" class="headerlink" title="定义只包含方法的类"></a>定义只包含方法的类</h4><p>在Python中要定义一个只包含方法的类，语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法1<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法2<span class="params">(self, 参数列表)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><ul><li>方法的定义格式和之前学习过的函数几乎一样</li><li>区别在于第一个参数必须是self</li></ul><p><strong>注意：类名的命名规则要符合大驼峰命名法</strong></p><h4 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h4><p>当一个类定义完成后，要使用这个类来创建对象，语法格式如下：<br><code>对象变量 = 类名()</code></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>31.面向对象使用</title>
      <link href="/2019/08/04/31-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/04/31-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="dir内置函数"><a href="#dir内置函数" class="headerlink" title="dir内置函数"></a>dir内置函数</h4><p>利用好dir()函数，可以查看对象内置的所有属性及方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">__new__      方法     创建对象时，会被自动调用</span><br><span class="line">__init__       方法      对象被初始化时，会被自动调用</span><br><span class="line">__del__       方法       对象被从内存中前，会被自动调用</span><br><span class="line">__str__         方法       返回对象的信息描述，<span class="keyword">print</span> 函数输出使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>30.面向对象</title>
      <link href="/2019/08/04/30-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>/2019/08/04/30-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h3 id="面向对象基本概念"><a href="#面向对象基本概念" class="headerlink" title="面向对象基本概念"></a>面向对象基本概念</h3><h4 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h4><p>相比较函数，面向对象是更大的封装，根据职责在一个对象中封装多个方法</p><ol><li>在完成某一需求前，首先确定职责——要做的事情（方法）</li><li>根据职责确定不同的对象，在对象内部封装不同的方法（多个）</li><li>最后完成的代码，就是顺序地让不同的对象调用不同的方法</li></ol><p><strong>特点</strong></p><ol><li>注重对象和职责，不同的对象承担不同的职责</li><li>更加适合应对复杂的需求变化，是专门应对复杂项目开发，提供的固定套路</li><li>需要在面向过程的基础上，再学习一些面向对象的语法</li></ol><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><ul><li><p>类是对一群具有相同特征或者行为的事物的一个统称，是抽象的，不能只是使用</p><ul><li>特征被称为属性</li><li>行为被称为方法</li></ul></li><li><p>对象是由类创建出来的一个具体存在，可以直接使用</p></li><li><p>由哪一个类创建出来的对象，就拥有在哪一个类中定义的</p><ul><li>属性</li><li>方法</li></ul></li></ul><p><strong>在程序开发中，应该先有类，再有对象</strong></p><h4 id="类和对象的关系"><a href="#类和对象的关系" class="headerlink" title="类和对象的关系"></a>类和对象的关系</h4><ul><li>类是模板，对象是根据类这个模板创建出来的，应该先有类，再有对象</li><li>类只有一个，而对象可以有很多个<ul><li>不同对象之间属性可能会各不相同</li></ul></li><li>类中定义了什么属性和方法，对象中就有什么属性和方法，不可能多，也不可能少</li></ul><h4 id="类的设计"><a href="#类的设计" class="headerlink" title="类的设计"></a>类的设计</h4><p>在使用面向对象开发前，应该首先分析需求，确定一下，程序中需要包含哪些类！</p><p>在程序开发中，要设置一个类，通常要满足一下三个要素</p><ol><li><strong>类名</strong>，这类事物的名字，满足大驼峰命名法（每一个单词首字母大写，第一个也大写）</li><li><strong>属性</strong>，这类事物具有什么样的特征</li><li><strong>方法</strong>，这类事物具有什么样的行为</li></ol><h4 id="类名的确定"><a href="#类名的确定" class="headerlink" title="类名的确定"></a>类名的确定</h4><p>名词提炼法分析整个业务流程图，出现的名词，通常就是要找到的类</p><h4 id="属性和方法的确定"><a href="#属性和方法的确定" class="headerlink" title="属性和方法的确定"></a>属性和方法的确定</h4><ul><li>对 对象的特征描述，通常可以定义成属性</li><li>对象具有的行为（动词），通常可以定义成方法</li></ul><p><strong>提示</strong>：需求中没有涉及的属性或者方法在涉及类时，不需要考虑</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面向对象 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>29.函数的递归</title>
      <link href="/2019/08/04/29-%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92/"/>
      <url>/2019/08/04/29-%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<h3 id="函数的递归"><a href="#函数的递归" class="headerlink" title="函数的递归"></a>函数的递归</h3><p>函数调用自身的编程技巧称为递归</p><h4 id="递归函数的特点"><a href="#递归函数的特点" class="headerlink" title="递归函数的特点"></a>递归函数的特点</h4><p><strong>特点</strong></p><ul><li>一个函数内部调用自己<br>函数内部可以调用其他函数，当然在函数内部也可以调用自己</li><li>代码特点</li></ul><ol><li>函数内部的代码是相同的，只是针对参数不同，处理的结果不同</li><li>当参数满足一个条件时，函数不再执行<ul><li>这个<strong>非常重要</strong>，通常被称为递归的出口，否则就会出现死循环</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>28.缺省参数</title>
      <link href="/2019/08/04/28-%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/"/>
      <url>/2019/08/04/28-%E7%BC%BA%E7%9C%81%E5%8F%82%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h3><ul><li>定义 函数时，可以给某个参数指定一个默认值，具有默认值的参数就叫做缺省参数</li><li>调用函数时，如果没有传入缺省参数的值，则在函数内部使用定义函数时指定的参数默认值</li><li>函数的缺省参数，将常见的值设置为参数的缺省值，从而简化函数的调用</li><li>例如：对列表的排序方法<br><code>sort()</code><br><code>sort(reverse=True)</code></li></ul><h4 id="指定参数的缺省值"><a href="#指定参数的缺省值" class="headerlink" title="指定参数的缺省值"></a>指定参数的缺省值</h4><p>在参数后使用赋值语句，可以指定参数的缺省值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_info</span><span class="params">(name, gender=True)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    :param name: 班上同学姓名</span></span><br><span class="line"><span class="string">    :param gender: True为男生，False为女神</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    gender_text = <span class="string">"男生"</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> gender:</span><br><span class="line">        gender_text = <span class="string">"女"</span></span><br><span class="line">    print(name,  gender_text)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print_info(<span class="string">"hh"</span>, <span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ol><li>缺省参数，需要使用最常见的值作为默认值</li><li>如果一个参数的值不能确定，则不应该设置默认值，具体的数值在调用函数时，由外界传递</li></ol><h4 id="缺省参数的注意事项"><a href="#缺省参数的注意事项" class="headerlink" title="缺省参数的注意事项"></a>缺省参数的注意事项</h4><ul><li>缺省参数的定义位置<br>必须保证带有默认值的缺省参数在参数列表末尾</li><li>调用带有多个缺省参数的函数<br>在函数调用时，如果有多个缺省参数，需要指定参数名，这样解释器才能知道参数的对应关系</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>27.函数参数和返回值作用</title>
      <link href="/2019/08/04/27-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%9C%E7%94%A8/"/>
      <url>/2019/08/04/27-%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%92%8C%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(a, b, *args, **kwargs)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line">(<span class="number">33</span>, <span class="number">44</span>)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'laowang'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(a, b, *args, **kwargs)</span>:</span></span><br><span class="line">    print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(args)</span><br><span class="line">print(kwargs)</span><br><span class="line">test2(a, b, args, kwargs)<span class="comment"># 相当于test2(11, 22, (33, 44), &#123; "name":"laowang", "age":18&#125;</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line">((<span class="number">33</span>, <span class="number">44</span>), &#123;<span class="string">'name'</span>: <span class="string">'laowang'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test2(a, b, *args, kwargs)   # 相当于test2(11, 22, 33, 44, &#123;"name":"laowang", "age":18&#125;</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line">(<span class="number">33</span>, <span class="number">44</span>, &#123;<span class="string">'name'</span>: <span class="string">'laowang'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;)</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># test2(a, b, *args, **kwargs)   # 相当于test2(11, 22, 33, 44, name="laowang", age=18&#125;</span></span><br><span class="line">输出：</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line">(<span class="number">33</span>, <span class="number">44</span>)</span><br><span class="line">&#123;<span class="string">'name'</span>: <span class="string">'laowang'</span>, <span class="string">'age'</span>: <span class="string">'18'</span>&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">test1(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"><span class="comment"># 输出：</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">22</span></span><br><span class="line">()</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="函数参数和返回值作用"><a href="#函数参数和返回值作用" class="headerlink" title="函数参数和返回值作用"></a>函数参数和返回值作用</h3><p>函数根据有没有参数一级有没有返回值，可以相互组合，一共有4种组合形式<br>1，无参数，无返回值<br>2，无参数，有返回值<br>3，有参数，有返回值<br>4，有参数，有返回值</p><p>函数：封装独立功能的代码，在需要时通过函数名被调用，可以直接访问全局变量<br>参数：外界希望在函数内部处理的数据<br>返回值：向外界报告函数的执行结果</p><p><strong>定义函数时，是否接收参数，或者是否返回结果，是根据实际功能需求来决定的</strong><br>1，如果函数内部处理的数据不确定，就可以将外界的数据以参数传递到函数内部<br>2，如果希望一个函数执行完成后，向外界汇报执行结果，就可以增加函数的返回值</p><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>元组可以包含多个数据，因此可以使用元组让函数一次返回多个值<br>如果函数返回的类型是元组，小括号可以省略</p><p>如果函数返回的类型是元组，同事希望单独处理元组中的元素，可以使用多个变量，一次接受函数的返回结果<br>注意：使用多个变量接收结果时，变量的个数应该和元组中的个数保持一致</p><p>(交换数据，右边的是一个元组，可以省去括号)<br>a, b = b, a</p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>参数是可变类型的，如果一个是使用方法，一个是使用赋值，则赋值的不变，使用方法的变</p><ol><li>无论传递的参数是可变还是不可变，只要<strong>针对参数</strong>使用 <strong>赋值语句</strong> ，会在函数内部修改局部变量的引用，不会影响到外部变量的引用</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num, num_list)</span>:</span></span><br><span class="line">    <span class="comment"># 在函数内部，针对参数使用赋值语句，不会修改到外部的实参变量</span></span><br><span class="line">    num = <span class="number">100</span></span><br><span class="line">    num_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">    print(num)</span><br><span class="line">    print(num_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gl_num = <span class="number">90</span></span><br><span class="line">gl_list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">demo(gl_num, gl_list)</span><br><span class="line">print(gl_num)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line"><span class="number">90</span></span><br><span class="line">[<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br></pre></td></tr></table></figure><ol start="2"><li>如果传递的参数是 <strong>可变类型</strong>，在函数内部，使用 <strong>方法</strong> 修改了数据的内容，同样会影响到外部的数据</li></ol> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">(num_list)</span>:</span></span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数内部的代码"</span>)</span><br><span class="line">    <span class="comment"># 使用方法修改列表的内容</span></span><br><span class="line">    num_list.append(<span class="number">9</span>)  <span class="comment"># 参数的话是没有提示方法的</span></span><br><span class="line">    print(num_list)</span><br><span class="line">    print(<span class="string">"函数执行完成"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gl_list = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">demo(gl_list)</span><br><span class="line">print(gl_list)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>]</span><br><span class="line">函数内部的代码</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br><span class="line">函数执行完成</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><ol start="3"><li>列表变量使用 += 不会做相加再赋值的操作，本质上是在调用列表的extend方法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">不变</span><br><span class="line">num_list = num_list +num_list</span><br><span class="line">变</span><br><span class="line">num_list += num_list 等价于 num_list.extend(num_list)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>26.名片管理系统</title>
      <link href="/2019/08/03/26-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2019/08/03/26-%E5%90%8D%E7%89%87%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h3 id="名片管理系统框架搭建"><a href="#名片管理系统框架搭建" class="headerlink" title="名片管理系统框架搭建"></a>名片管理系统框架搭建</h3><p>1，准备文件，确定文件名，保证能够在需要的位置编写代码<br>2，编写主运行循环，实现基本的用户输入和判断</p><h4 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断"></a>字符串判断</h4><p> 1，使用 in 针对列表判断，避免使用or 拼接复杂的逻辑条件<br> 2，没有使用int 转换用户输入，可以避免一旦用户输入的不是数字，导致程序运行出错</p><h4 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h4><p>pass就是一个空语句，不做任何事情，一般用作站位语句，是为了保持程序结构的完整性</p><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>在开发软件时，如果不希望程序执行后立即退出，可以在程序中增加一个无限循环，由用户来决定退出程序的时机</p><h4 id="TODO注释"><a href="#TODO注释" class="headerlink" title="TODO注释"></a>TODO注释</h4><p>在 # 后跟上 TODO ，用于标记需要去做的工作<br><code># TODO(xxx) xxx</code><br>return 可以返回一个函数的执行结果，下方的代码不会被执行，如果return后面没有任何内容，表示会返回到调用函数的位置并且不返回任何结果</p><p>注释文档在写完函数之后，别忘了写</p><h4 id="cards-main-py"><a href="#cards-main-py" class="headerlink" title="cards_main.py"></a>cards_main.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cards_tools</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cards_tools.show_menu()</span><br><span class="line"></span><br><span class="line">    action = input(<span class="string">"请选择操作功能"</span>)</span><br><span class="line">    print(<span class="string">"您的输入是【%s】"</span> % action)</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    前面是没有加int的话</span></span><br><span class="line"><span class="string">    可以用 if act in ["1", "2", "3"]</span></span><br><span class="line"><span class="string">    然后用 elif,else</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="comment">#  新增名片</span></span><br><span class="line">    <span class="keyword">if</span> action == <span class="string">"1"</span>:</span><br><span class="line">        cards_tools.new_card()</span><br><span class="line">    <span class="comment"># 显示全部</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">"2"</span>:</span><br><span class="line">        cards_tools.show_all()</span><br><span class="line">    <span class="comment"># 查询名片</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">"3"</span>:</span><br><span class="line">        cards_tools.search_card()</span><br><span class="line">    <span class="comment"># 退出系统</span></span><br><span class="line">    <span class="keyword">elif</span> action == <span class="string">"0"</span>:</span><br><span class="line">        print(<span class="string">"欢迎再次使用系统"</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"您的输入有误，请重新输入"</span>)</span><br></pre></td></tr></table></figure><h4 id="cards-tools-py"><a href="#cards-tools-py" class="headerlink" title="cards_tools.py"></a>cards_tools.py</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 记录所有的名片的字典</span></span><br><span class="line">card_list = []</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_menu</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    显示菜单</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"欢迎使用名片管理系统\n1.新建名片\n2.显示全部\n3.查询名片\n\n0.退出系统"</span>)</span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">new_card</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    新增名片</span></span><br><span class="line"><span class="string">    :return:</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"新增名片"</span>)</span><br><span class="line">    <span class="comment"># 1.提示用户输入名片的详细信息</span></span><br><span class="line">    name_str = input(<span class="string">"请输入姓名"</span>)</span><br><span class="line">    phone_str = input(<span class="string">"请输入电话"</span>)</span><br><span class="line">    qq_str = input(<span class="string">"请输入qq"</span>)</span><br><span class="line">    email_str = input(<span class="string">"请输入邮箱"</span>)</span><br><span class="line">    <span class="comment"># 2.使用用户输入的信息建立一个名片字典</span></span><br><span class="line">    card_dict = &#123;<span class="string">"name"</span>: name_str,</span><br><span class="line">                 <span class="string">"phone"</span>: phone_str,</span><br><span class="line">                 <span class="string">"qq"</span>: qq_str,</span><br><span class="line">                 <span class="string">"email"</span>: email_str&#125;</span><br><span class="line">    <span class="comment"># 3.讲名片字典添加到列表中</span></span><br><span class="line">    card_list.append(card_dict)</span><br><span class="line">    print(card_list)</span><br><span class="line">    <span class="comment"># 4.提示用户添加成功</span></span><br><span class="line">    print(<span class="string">"%s 添加成功"</span> % name_str)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_all</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""显示所有名片"""</span></span><br><span class="line">    <span class="comment"># 判断是否存在名片记录，如果没有，提示并返回</span></span><br><span class="line">    <span class="keyword">if</span> len(card_list) == <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"没有名片记录"</span>)</span><br><span class="line">        <span class="comment"># return 可以返回一个函数的执行结果，下方的代码不会被执行，如果return后面没有任何内容，表示会返回到调用函数的位置并且不返回任何结果</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="comment"># 打印表头</span></span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"显示所有名片"</span>)</span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">"name"</span>, <span class="string">"phone"</span>, <span class="string">"qq"</span>, <span class="string">"email"</span>]:</span><br><span class="line">        print(name, end=<span class="string">"\t\t\t"</span>)</span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line">    <span class="comment"># 打印分割线</span></span><br><span class="line">    print(<span class="string">"="</span> * <span class="number">50</span>)</span><br><span class="line">    <span class="comment"># 遍历输出字典信息</span></span><br><span class="line">    <span class="keyword">for</span> card_dict <span class="keyword">in</span> card_list:</span><br><span class="line">        print(<span class="string">"%s\t\t\t%s\t\t\t%s\t\t\t%s\t\t\t"</span> % (card_dict[<span class="string">"name"</span>],</span><br><span class="line">                                                    card_dict[<span class="string">"phone"</span>],</span><br><span class="line">                                                    card_dict[<span class="string">"qq"</span>],</span><br><span class="line">                                                    card_dict[<span class="string">"email"</span>]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search_card</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    查找名片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(<span class="string">"-"</span>*<span class="number">20</span>)</span><br><span class="line">    print(<span class="string">"查找名片"</span>)</span><br><span class="line">    <span class="comment"># 1.提示用户输入要搜索的名字</span></span><br><span class="line">    find_name = input(<span class="string">"请输入要搜索的姓名："</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.遍历名片列表，查询要搜索的名字，如果没有找到，需要提示用户</span></span><br><span class="line">    <span class="keyword">for</span> card_dict <span class="keyword">in</span> card_list:</span><br><span class="line">        <span class="keyword">if</span> find_name == card_dict[<span class="string">"name"</span>]:</span><br><span class="line">            print(<span class="string">"找到了"</span>)</span><br><span class="line">            print(<span class="string">"name\t\t\tphone\t\t\tqq\t\t\temail"</span>)</span><br><span class="line">            print(<span class="string">"="</span>*<span class="number">20</span>)</span><br><span class="line">            print(<span class="string">"%s\t\t\t%s\t\t\t%s\t\t\t%s"</span> % (card_dict[<span class="string">"name"</span>],</span><br><span class="line">                                                  card_dict[<span class="string">"phone"</span>],</span><br><span class="line">                                                  card_dict[<span class="string">"qq"</span>],</span><br><span class="line">                                                  card_dict[<span class="string">"email"</span>]))</span><br><span class="line">            <span class="comment"># 增加修改删除功能</span></span><br><span class="line">            deal_card(card_dict)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"没找到%s"</span> % find_name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_card</span><span class="params">(find_dict)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    处理查找到的名片</span></span><br><span class="line"><span class="string">    :param find_dict: 查找到的名片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    print(find_dict)</span><br><span class="line">    action_str = input(<span class="string">"请选择要选择的操作，"</span></span><br><span class="line">                       <span class="string">"1，修改  2，删除  0返回上一级"</span>)</span><br><span class="line">    <span class="keyword">if</span> action_str == <span class="string">"1"</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"修改名片成功"</span>)</span><br><span class="line">        find_dict[<span class="string">"name"</span>] = input_card_info(find_dict[<span class="string">"name"</span>], <span class="string">"姓名："</span>)</span><br><span class="line">        find_dict[<span class="string">"phone"</span>] = input_card_info(find_dict[<span class="string">"phone"</span>], <span class="string">"phone："</span>)</span><br><span class="line">        find_dict[<span class="string">"qq"</span>] = input_card_info(find_dict[<span class="string">"qq"</span>], <span class="string">"qq："</span>)</span><br><span class="line">        find_dict[<span class="string">"email"</span>] = input_card_info(find_dict[<span class="string">"email"</span>], <span class="string">"email："</span>)</span><br><span class="line">    <span class="keyword">elif</span> action_str == <span class="string">"2"</span>:</span><br><span class="line">        card_list.remove(find_dict)</span><br><span class="line">        print(<span class="string">"删除名片成功"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">input_card_info</span><span class="params">(dict_value, tip_message)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    修改</span></span><br><span class="line"><span class="string">    1.提示用户输入</span></span><br><span class="line"><span class="string">    2，针对用户输入进行判断，如果用户输入了内容，直接返回结果</span></span><br><span class="line"><span class="string">    3，如果没有输入，返回原来的值</span></span><br><span class="line"><span class="string">    :param dict_value: 字典中原有值</span></span><br><span class="line"><span class="string">    :param tip_message: 输入提示文字</span></span><br><span class="line"><span class="string">    :return: 若输入有信息，则更新信息，若没输入，则返回原来信息</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    result_str = input(tip_message)</span><br><span class="line">    <span class="keyword">if</span> len(result_str) &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> result_str</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> dict_value</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>25.公共方法（2）完整的for循环语法</title>
      <link href="/2019/08/03/25-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%EF%BC%882%EF%BC%89%E5%AE%8C%E6%95%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95/"/>
      <url>/2019/08/03/25-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%EF%BC%882%EF%BC%89%E5%AE%8C%E6%95%B4%E7%9A%84for%E5%BE%AA%E7%8E%AF%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="完整的for循环语法"><a href="#完整的for循环语法" class="headerlink" title="完整的for循环语法"></a>完整的for循环语法</h3><p>在Python中完整的for循环的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 变量 <span class="keyword">in</span> 集合:</span><br><span class="line">循环体代码</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">没有通过<span class="keyword">break</span>退出循环，循环结束后，会执行的代码</span><br></pre></td></tr></table></figure><p>如果使用了break，那么else的代码就不会执行</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>在迭代遍历嵌套的数据类型时，例如一个列表包含了多个字典</li><li>需求：要判断某一字典中是否存在指定的值<ol><li>如果存在，提示并且退出循环</li><li>如果不存在，在循环整体结束后，希望得到一个统一的提示</li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">students = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"张三"</span>, <span class="string">"sex"</span>: <span class="number">1</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"李四"</span>, <span class="string">"sex"</span>: <span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">]</span><br><span class="line"><span class="comment"># 搜索指定的姓名</span></span><br><span class="line">find_name = <span class="string">"张三"</span></span><br><span class="line"><span class="keyword">for</span> stu_dict <span class="keyword">in</span> students:</span><br><span class="line">    print(stu_dict)</span><br><span class="line">    <span class="keyword">if</span> stu_dict[<span class="string">"name"</span>] == find_name:</span><br><span class="line">        print(<span class="string">"找到了 %s"</span> % find_name)</span><br><span class="line"><span class="comment"># 找到结束</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="comment"># 如果在搜索列表时，所有的字典检查之后，都没有需要的目标，得到一个统一的提示</span></span><br><span class="line">print(<span class="string">"没找到"</span>)</span><br><span class="line">print(<span class="string">"循环结束"</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公共方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>24.公共方法（1）运算符</title>
      <link href="/2019/08/03/24-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%EF%BC%881%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2019/08/03/24-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%EF%BC%881%EF%BC%89%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table><thead><tr><th>运算符</th><th>Python 表达式</th><th>结果</th><th>描述</th><th>支持的数据类型</th></tr></thead><tbody><tr><td>+</td><td>[1, 2] + [3, 4]</td><td>[1, 2, 3, 4]</td><td>合并</td><td>字符串、列表、元组</td></tr><tr><td>*</td><td>[hi]</td><td>[‘hi’, ‘hi’, ‘hi’, ‘hi’]</td><td>重复</td><td>字符串、列表、元组</td></tr><tr><td>in</td><td>3 in (1, 2, 3)</td><td>True</td><td>元素是否存在</td><td>字符串、列表、元组、字典</td></tr><tr><td>not in</td><td>4 not in (1, 2, 3)</td><td>True</td><td>元素是否不存在</td><td>字符串、列表、元组、字典</td></tr><tr><td>&gt; &gt;= == &lt; &lt;=</td><td>(1, 2, 3) &lt; (2, 3, 3)</td><td>True</td><td>元素比较</td><td>字符串、列表、元组</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>in 在对字典进行操作时，判断的是字典的键</li><li>in 和 not in 被称为成员运算符</li><li>extends 和 append 连接的时候，会生成一个新的对象，不修改原有对象</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公共方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22.公共方法</title>
      <link href="/2019/08/02/22-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/02/22-%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="python内置函数"><a href="#python内置函数" class="headerlink" title="python内置函数"></a>python内置函数</h3><p>python包含了一下内置函数：</p><table><thead><tr><th>函数</th><th>描述</th><th>备注</th></tr></thead><tbody><tr><td>len(item)</td><td>计算容器中元素个数</td><td></td></tr><tr><td>del(item)</td><td>删除变量</td><td>del 有两种方式，关键字或函数</td></tr><tr><td>max(item)</td><td>返回容器中元素最大值</td><td>如果是字典，只针对key比较</td></tr><tr><td>min(item)</td><td>返回容器中元素最小值</td><td>如果是字典，只针对key比较</td></tr><tr><td>cmp(item1, item2)</td><td>比较大小</td><td>python3取消，可用&lt;&gt;=比较运算符</td></tr></tbody></table><p>注意：字符串比较符合一下规则：“0”&lt; “A” &lt;”a”</p><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><table><thead><tr><th>描述</th><th>python表达式</th><th>结果</th><th>支持的数据类型</th></tr></thead><tbody><tr><td>切片</td><td>“0123456789”[::-2]</td><td>“97531”</td><td>字符串、列表、元组</td></tr></tbody></table><ul><li>切片使用索引值来限定范围，从一个大的字符串中切出小的字符串</li><li>列表和元组都是有序的集合，都能够通过索引值获取到对应的数据</li><li>字典是要给无序的集合，是使用键值对保存数据</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 公共方法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.字符串的切片</title>
      <link href="/2019/08/02/21-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%87%E7%89%87/"/>
      <url>/2019/08/02/21-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%88%87%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串的切片"><a href="#字符串的切片" class="headerlink" title="字符串的切片"></a>字符串的切片</h3><ul><li>切片方法适用于字符串、列表、元组</li></ul><ol><li>切片使用索引值来限定范围，从一个大的字符串中切出小的字符串</li><li>列表和元组都是有序的集合，都能够通过索引值获取到对应的数据</li><li>字典是一个无需的集合，是用键值对保存数据<br><code>字符串[开始索引 : 结束索引 : 步长]</code><br>逆序：字符串[: :-1]<br><strong>注意：</strong><br>1 .  指定的区间属于左闭右开型，从开始位开始，到结束位的前一位（不包括结束位本身）<br>2 .  从头开始，开始索引数字可以省略，冒号不能省略<br>3 .  到末尾结束，结束索引数字可以省略，冒号不能省略<br>4 .  步长默认为1，如果连续切片，数字和冒号都可以省略</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>20.字符串常用方法</title>
      <link href="/2019/08/02/20-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2019/08/02/20-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="判断类型-9"><a href="#判断类型-9" class="headerlink" title="判断类型-9"></a>判断类型-9</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.isspace()</td><td>如果string 中只包含空格，则返回True （’\t’, ‘\r’, ‘\n’）</td></tr><tr><td>string.isalnum()</td><td>如果string 至少有一个字符并且所有字符都是字母或数字则返回True</td></tr><tr><td>string.isalpha()</td><td>如果string 至少有一个字符并且所有字符都是字母则返回True</td></tr><tr><td>string.isdecimal()</td><td>如果string 只包含数字则返回True，全角数字 （常用）</td></tr><tr><td>string.isdigit</td><td>如果string 只包含数字则返回True，全角数字、（1）、\u00b2</td></tr><tr><td>string.isnumeric()</td><td>如果string 只包含数字则返回True，全角数字，汉字数字</td></tr><tr><td>string.istitle()</td><td>如果string 是标题化的（每个单词的首字母大写）则返回True</td></tr><tr><td>string.islower()</td><td>如果string 包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是小写的，则返回True</td></tr><tr><td>string.isupper()</td><td>如果string 中包含至少一个区分大小写的字符，并且所有这些（区分大小写的）字符都是大写，则返回True</td></tr></tbody></table><h3 id="查找和替换-7"><a href="#查找和替换-7" class="headerlink" title="查找和替换-7"></a>查找和替换-7</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.starstwith(str)</td><td>检查字符串是否以str开头（区分大小写），是则返回True</td></tr><tr><td>string.endswith(str)</td><td>检查字符串是否以str 结束（区分大小写），是则返回True</td></tr><tr><td>string.find(str, start=0, end=len(string))</td><td>检测str包含在string中，如果start和end指定范围，则检查是否包含在指定范围内，如果是返回开始的索引值，否则（不存在）返回-1，（index同样可以查找指定的字符串在大字符串中的索引，如果指定的字符串不存在，会报错）</td></tr><tr><td>stiring.rfind(str, start=0, end=len(string))</td><td>类似于find()函数，不过是从右边开始查找</td></tr><tr><td>string.index(str, start=0, end=len(string))</td><td>跟find()方法类似，只不过str不在string会报错</td></tr><tr><td>string.rindex(str, start=0, end=len(string))</td><td>类似于index()，不过是从右边开始</td></tr><tr><td>string.replace(old_str, new_str, num=string.count(old))</td><td>把是string 中的old_str 替换成new_str，如果num 指定，则替换不超过 num次（replace方法执行完成后，会返回一个新的字符串，注意：不会修改原有的字符串内容）</td></tr></tbody></table><h3 id="大小写转换-5"><a href="#大小写转换-5" class="headerlink" title="大小写转换-5"></a>大小写转换-5</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.capitalize()</td><td>把字符串的第一个字符大写</td></tr><tr><td>string.title()</td><td>把字符串的每个单子首字母大写</td></tr><tr><td>string.lower()</td><td>转换string 中所有大写字符为小写</td></tr><tr><td>string.upper()</td><td>转换string中的小写字母为大写</td></tr><tr><td>string.swapcase()</td><td>翻转string中的大小写</td></tr></tbody></table><h3 id="文本对齐-3"><a href="#文本对齐-3" class="headerlink" title="文本对齐-3"></a>文本对齐-3</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.ljust(width)</td><td>返回一个原字符串左对齐，并使用空格填充至width的新字符串</td></tr><tr><td>string.rjust(width)</td><td>返回一个原字符串右对齐，并使用空格填充至width的新字符串</td></tr><tr><td>string.center(width)</td><td>返回一个原字符串居中，并使用空格填充至width的新字符串</td></tr></tbody></table><h3 id="去除空白字符-3"><a href="#去除空白字符-3" class="headerlink" title="去除空白字符-3"></a>去除空白字符-3</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>sting.lstrip()</td><td>截掉string左边（开始）的空白字符</td></tr><tr><td>string.rstrip()</td><td>截掉string右边（末尾）的空白字符</td></tr><tr><td>string.strip()</td><td>截掉string左右两边的空白字符</td></tr></tbody></table><h3 id="拆分和连接-5"><a href="#拆分和连接-5" class="headerlink" title="拆分和连接-5"></a>拆分和连接-5</h3><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>string.partition(str)</td><td>把字符串string分成一个3元组的元组（str前面, str, str后面）</td></tr><tr><td>string.rpartition</td><td>类似于partition()函数，不过是从右边开始查找</td></tr><tr><td>string.split(str=””, num)</td><td>以str为分隔符切片string，如果num有指定值，则仅分隔num+1个子字符串，str默认包含’\t’, ‘\r’, ‘\n’和空格</td></tr><tr><td>string.splitlines()</td><td>按照行（’\t’, ‘\r’, ‘\n’）分隔，返回一个包含各行元素的列表</td></tr><tr><td>string.join(seq)</td><td>以string 作为分隔符，将seq中所有的元素（的字符串表示）合并为一个新的字符串</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>19.字符串</title>
      <link href="/2019/08/02/19-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2019/08/02/19-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="字符串的定义"><a href="#字符串的定义" class="headerlink" title="字符串的定义"></a>字符串的定义</h3><ul><li>字符串就是一串字符，是编程语言中表示文本的数据类型</li><li>在python中可以使用一对双引号 “ 或者一对单引号 ‘ 来定义一个字符串<br>虽然可以使用 \”或者&#39; 做字符串的转义，但是在实际开发中：<br>如果字符串内部需要使用 “ ,可以使用 ‘ 定义字符串<br>如果字符串内部需要使用 ‘ ,可以使用 “ 定义字符串</li><li>也可以使用索引获取字符串中指定位置的字符，索引计数从0开始</li><li>也可以使用 for 循环遍历字符串中每一个字符<br>大多数编程语言都是用 ”来定义字符串<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string = <span class="string">"hello python"</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> string:</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure></li></ul><p>len(字符串) 获取字符串的长度<br>字符串.count(字符串) 小字符串在大字符串中出现的次数<br>字符串[索引] 从字符串中取出单个字符<br>字符串.index(字符串)获得小字符串第一次出现的索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">hello_str = <span class="string">"hello py"</span></span><br><span class="line"><span class="comment"># 统计字符串长度</span></span><br><span class="line">print(len(hello_str))</span><br><span class="line"><span class="comment"># 统计某一个子字符串出现的次数</span></span><br><span class="line">print(hello_str.count(<span class="string">"l"</span>))</span><br><span class="line"><span class="comment"># 某一个子字符串出现的位置，注意：如果使用index方法传递的子字符串不存在，程序会报错</span></span><br><span class="line">print(hello_str.index(<span class="string">"aaa"</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>18.字典（1）循环遍历</title>
      <link href="/2019/08/02/18-%E5%AD%97%E5%85%B8%EF%BC%881%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86/"/>
      <url>/2019/08/02/18-%E5%AD%97%E5%85%B8%EF%BC%881%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p>遍历基于是以此从字典中获取所有键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环内部使用的“key”的变量 <span class="keyword">in</span> 字典：</span><br><span class="line">内容....</span><br></pre></td></tr></table></figure><p>提示:在实际开发中，由于字典中每一个键值对保存数据的类型是不同的，所以针对字典的遍历需求并不是很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">19</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.84</span>&#125;</span><br><span class="line"><span class="comment"># 迭代遍历字典</span></span><br><span class="line"><span class="comment"># 遍历k是每一次循环重，获取到的键值对的key</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> xiaoming:</span><br><span class="line">    print(<span class="string">"%s ——%s"</span> % (k, xiaoming[k]))</span><br></pre></td></tr></table></figure><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>尽管可以使用for in 遍历字典</li><li>但是在开发中，更多的应用场景是：</li></ul><ol><li>使用多个键值对，存储描述一个物体相关的信息——描述更复杂的数据信息</li><li>将多个字典放在一个列表中，再进行遍历，再循环体内部针对每一个字典进行相同的处理<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">car_list = [</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"li"</span>,</span><br><span class="line">     <span class="string">"sex"</span>: <span class="string">"boy"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">22</span>&#125;,</span><br><span class="line">    &#123;<span class="string">"name"</span>: <span class="string">"liaa"</span>,</span><br><span class="line">     <span class="string">"sex"</span>: <span class="string">"boy"</span>,</span><br><span class="line">     <span class="string">"age"</span>: <span class="number">22</span>&#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> car_info <span class="keyword">in</span> car_list:</span><br><span class="line">    print(car_info)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17.字典</title>
      <link href="/2019/08/02/17-%E5%AD%97%E5%85%B8/"/>
      <url>/2019/08/02/17-%E5%AD%97%E5%85%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="字典的定义"><a href="#字典的定义" class="headerlink" title="字典的定义"></a>字典的定义</h3><ul><li>dictionary （字典）是除列表以为python之中最灵活的数据类型</li><li>字典通用可以用来存储多个数据</li></ul><ol><li>通常用来存储一个物体的相关信息</li></ol><ul><li>和列表的区别</li></ul><ol><li>列表是有序的对象集合</li><li>字典是无序的对象集合</li></ol><ul><li>字典用 {} 定义</li><li>字典用键值对存储数据，键值对之间使用 ，分隔</li></ul><ol><li>键 key 是索引</li><li>值 value 是数据</li><li>键和值之间使用 ：分隔</li><li>键必须是唯一的</li><li>值 可以取任何数据类型， 但键 只能使用 字符串、数据或元组<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xiaoming = &#123;<span class="string">"name"</span>: <span class="string">"小明"</span>,</span><br><span class="line">            <span class="string">"age"</span>: <span class="number">19</span>,</span><br><span class="line">            <span class="string">"height"</span>: <span class="number">1.84</span>&#125;</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取值，在取值的时候，如果指定的key不存在，程序会报错</span></span><br><span class="line">print(xiaoming[<span class="string">"name"</span>])</span><br><span class="line"><span class="comment"># 增加/修改</span></span><br><span class="line"><span class="comment"># 如果key不存在，会增加新键值对，如果key存在，会修改已经存在的键值对</span></span><br><span class="line">xiaoming[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line"><span class="comment"># 删除</span></span><br><span class="line"><span class="comment"># 在删除指定键值对的时候，如果指定的key不存在，程序会报错</span></span><br><span class="line">xiaoming.pop(<span class="string">"height"</span>)</span><br><span class="line"><span class="comment"># 统计键值对数量</span></span><br><span class="line">print(len(xiaoming))</span><br><span class="line"><span class="comment"># 合并字典，注意:如果被合并的字典中包含已经存在的键值对，会覆盖原有的键值对</span></span><br><span class="line">temp_dict = (<span class="string">"height"</span>:<span class="number">178</span>, <span class="string">"age"</span>:<span class="number">33</span>)</span><br><span class="line">xiaoming.update(temp_dict)</span><br><span class="line"><span class="comment"># 清空字典</span></span><br><span class="line">xiaoming.clear()</span><br><span class="line">print(xiaoming)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字典 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>16.元组（1）循环遍历</title>
      <link href="/2019/08/02/16-%E5%85%83%E7%BB%84%EF%BC%881%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86/"/>
      <url>/2019/08/02/16-%E5%85%83%E7%BB%84%EF%BC%881%EF%BC%89%E5%BE%AA%E7%8E%AF%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><ul><li><p>取值就是从元组中获取存储在指定位置的数据</p></li><li><p>遍历就是从头到尾一次从元组中获取数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> 循环内部使用的变量 <span class="keyword">in</span> 元组：</span><br><span class="line">    循环内部针对元组进行操作</span><br></pre></td></tr></table></figure></li><li><p>在python中，可以使用for循环遍历所有非数字类型的遍历：列表、元组、字典以及字符串</p></li><li><p>提示：在实际开发中，除非能够确认元组中的数据类型，否则针对元组的循环遍历要求并不是很多</p></li></ul><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>尽管可以使用 for in 遍历元组</li><li>但是在开发中，更多的应用场景是：</li></ul><ol><li>函数的参数和返回值，一个函数可以接收任意多个参数，或者一次返回多个数据</li><li>格式字符串，格式化字符串后面的（）本质上就是一个元组</li><li>让列表不可以被修改，以保护数据安全<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">info = (<span class="string">"zhangsan"</span>, <span class="number">18</span>)</span><br><span class="line">print(<span class="string">"%s 的年龄是 %d"</span> % info)</span><br></pre></td></tr></table></figure></li></ol><p><strong>元组和列表之间的转换</strong></p><ul><li>使用list 函数可以把元组转换成列表<br><code>list(元组)</code></li><li>使用 tuple 函数可以把列表转换成元组<br><code>tuple(列表)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>15.元组</title>
      <link href="/2019/08/01/15-%E5%85%83%E7%BB%84/"/>
      <url>/2019/08/01/15-%E5%85%83%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h3 id="元组的定义"><a href="#元组的定义" class="headerlink" title="元组的定义"></a>元组的定义</h3><ul><li>Tuple（元组）与列表类似，不同之处在于元组的元素不能更改</li></ul><ol><li>元组表示多个元素组成的序列</li><li>元组在python开发中，有特定的应用场景</li></ol><ul><li>用于存储一串信息，数据之间使用 ，分隔</li><li>元组用（）定义</li><li>元组的索引从 0 开始<br>索引 就是数据在元组中的位置编号<br><code>info_tuple = (&quot;zhangsan &quot;, 22, 170)</code></li></ul><p><strong>元组中只包含一个元素时，需要在元素后面添加逗号</strong><br><code>info_tuple = (50, )</code><br><strong>没有逗号的话就是一个int类型的数据了</strong><br>.index（） 已经知道数据的内容，希望知道该数据在元组中的索引<br>.count()统计元组中元素出现的个数</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 元组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>14.列表（1）循环遍历</title>
      <link href="/2019/08/01/14-%E5%88%97%E8%A1%A8%EF%BC%882%EF%BC%89-1/"/>
      <url>/2019/08/01/14-%E5%88%97%E8%A1%A8%EF%BC%882%EF%BC%89-1/</url>
      
        <content type="html"><![CDATA[<h3 id="循环遍历"><a href="#循环遍历" class="headerlink" title="循环遍历"></a>循环遍历</h3><p>遍历就是从头到尾一次从列表中获取数据<br>在循环体内部针对每一个元素，执行相同的操作<br>在python中为了提高列表的遍历效率，专门提高迭代iteration 遍历<br>使用for 就能够实现迭代遍历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> 循环内部使用的变量 <span class="keyword">in</span> 列表：</span><br><span class="line">循环内部针对列表元素进行的操作</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li>尽管python的列表中可以存储不同类型的数据</li><li>但是在开发中，更多的应用场景事</li></ul><ol><li>列表 存储相同类型的数据</li><li>通过 迭代遍历，在循环体内部，针对列表中的每一项元素，执行相同的操作</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>13.列表（1）</title>
      <link href="/2019/08/01/13-%E5%88%97%E8%A1%A8%EF%BC%881%EF%BC%89/"/>
      <url>/2019/08/01/13-%E5%88%97%E8%A1%A8%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="关键字，函数和方法出坑"><a href="#关键字，函数和方法出坑" class="headerlink" title="关键字，函数和方法出坑"></a>关键字，函数和方法出坑</h3><ul><li>关键字是python内置的，具有特殊意义的标识符</li></ul><p><strong>关键字后面不需要使用括号</strong></p><ul><li>函数 封装了独立功能，可以直接调用</li></ul><p><em>函数名（参数）</em><br><strong>函数需要死记硬背</strong></p><ul><li>方法和函数类似，同样是封装了独立的功能</li><li>方法需要通过对象来调用，表针对这个对象要做的操作</li></ul><p><em>对象.方法名（参数）</em><br>在变量后面输入 . 然后选择针对这个变量要执行的操作，记忆起来比函数简单很多</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>12.列表</title>
      <link href="/2019/08/01/12-%E5%88%97%E8%A1%A8/"/>
      <url>/2019/08/01/12-%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="列表的定义"><a href="#列表的定义" class="headerlink" title="列表的定义"></a>列表的定义</h3><ul><li>list （列表） 是python中使用最频繁的数据类型，在其他语言中通常叫做数组</li><li>专门用于存储一串信息</li><li>列表用 [] 定义，数据之间使用 ，分隔</li><li>列表的索引从 0 开始<br>索引就是数据在列表中的位置编号，索引又可以被称为下表</li></ul><p><strong>注意：从列表中取值时，如果超出索引范围，程序会报错</strong></p><table><thead><tr><th>分类</th><th>关键字/函数/方法</th><th>说明</th></tr></thead><tbody><tr><td>增加</td><td>列表.insert(索引，数据)</td><td>在指定位置插入数据</td></tr><tr><td></td><td>列表.append(数据)</td><td>在末尾追加数据</td></tr><tr><td></td><td>列表.extend(列表2)</td><td>将列表2的数据追加到列表</td></tr><tr><td>修改</td><td>列表[索引] = 数据</td><td>修改指定索引的数据</td></tr><tr><td>删除</td><td>del 列表[索引]</td><td>删除指定索引的数据</td></tr><tr><td></td><td>列表.remove[数据]</td><td>删除第一个出现的指定数据</td></tr><tr><td></td><td>列表.pop</td><td>删除末尾数据</td></tr><tr><td></td><td>列表pop（索引）</td><td>删除指定索引数据</td></tr><tr><td></td><td>列表.clear</td><td>清空列表</td></tr><tr><td>统计</td><td>len（列表）</td><td>列表长度</td></tr><tr><td></td><td>列表.count（数据）</td><td>数据在列表中出现的次数</td></tr><tr><td>排序</td><td>列表.sort()</td><td>升序排序</td></tr><tr><td></td><td>列表.sort(reverse=True)</td><td>降序排序</td></tr><tr><td></td><td>列表.reverse()</td><td>逆序、反转</td></tr></tbody></table><p>提示：在日常开发中，要从列表删除数据，建议使用列表提供的方法<br>  注意：如果使用del 关键字将变量从内存中删除，后续代码就不能再使用这个变量了<br>  sort是一个方法，效果是永久的<br>  sorted是一个函数，sorted(list)如果不用变量接受就会被系统回收掉</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 列表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>11.预先知识</title>
      <link href="/2019/08/01/11-%E9%A2%84%E5%85%88%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/08/01/11-%E9%A2%84%E5%85%88%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>python 中的数据类型可分为数字型和非数字型</p><ul><li>非数字型：</li></ul><ol><li>字符串</li><li>列表</li><li>元组</li><li>字典</li></ol><ul><li>在python中，所有非数字型变量都支持以下特点：</li></ul><ol><li>都是一个序列 sequence ，也可以理解为容器</li><li>取值[]</li><li>遍历 for in</li><li>计算长度、最大/最小值、比较、删除</li><li>连接 + 和 重复 *</li><li>切片</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>10.模块中的函数</title>
      <link href="/2019/08/01/10-%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/01/10-%E6%A8%A1%E5%9D%97%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>模块是python程序构架的一个核心概念</strong></p><ul><li>模块就好比是工具包，要想使用这个工具包中的工具，就需要导入impor这个模块</li><li>每一个以扩展名py结尾的python源代码文件都是一个模块</li><li>在模块中定义的的全局变量、函数 都是模块能够提供给外界直接使用的工具</li></ul><p><strong>小结：</strong></p><ol><li>可以在一个python文件中定义变量或者函数</li><li>然后在另一个文件中使用impor导入这个模块</li><li>导入之后，就可以使用模块名.变量/模块名.函数的方式，使用这个模块中定义的变量或者函数</li></ol><p><strong>模块可以让编写过的代码方便的被复用</strong><br>模块名也是一个标识符，遵守标识符的规则</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>09.函数基本使用（1）</title>
      <link href="/2019/08/01/09-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%881%EF%BC%89/"/>
      <url>/2019/08/01/09-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>注意：定义好函数之后，只表示这个函数封装了一段代码而已，入托不主动调用函数，函数是不会主动执行的<br>** 不能将调用函数放在函数定义上方**否则控制台会提示 NameError：name xxx is not defined</p><h3 id="Pychram-的调试工具"><a href="#Pychram-的调试工具" class="headerlink" title="Pychram 的调试工具"></a>Pychram 的调试工具</h3><ul><li>F8 Step Over 可以单步执行代码，会把函数调用看作是一行代码直接执行</li><li>F7 Step Into 可以单步执行代码，如果是hi函数，会进入函数内部<h3 id="函数文档注释"><a href="#函数文档注释" class="headerlink" title="函数文档注释"></a>函数文档注释</h3></li><li>在开发中，如果希望给函数添加注释，应该在定义函数的下方，使用联系的三对引号</li><li>在连续的三对引号之间编写对函数的说明文字</li><li>在函数调用位置，使用快捷键ctrl + Q 可以查看函数的说明信息</li></ul><p><strong>注意：因为函数体相对独立，函数定义的上方，应该和其他代码（包括注释）保留两个空行</strong></p><h3 id="函数参数的使用"><a href="#函数参数的使用" class="headerlink" title="函数参数的使用"></a>函数参数的使用</h3><ul><li>在函数名的后面的小括号内部填写参数</li><li>多个参数之间使用 , 分隔<h3 id="参数的作用"><a href="#参数的作用" class="headerlink" title="参数的作用"></a>参数的作用</h3></li><li>函数，把具有独立功能的代码块组织为一个小模块，在需要的时候调用</li><li>函数的参数，增加函数的通用性，针对相同的数据处理逻辑，能适应更多的数据</li></ul><ol><li>在函数的内部，把参数当作变量使用，进行需要的数据处理</li><li>函数调用时，按照函数定义的参数顺序把希望在函数内部处理的数据，通过参数传递<h3 id="形参和实参"><a href="#形参和实参" class="headerlink" title="形参和实参"></a>形参和实参</h3></li></ol><ul><li>形参：定义函数时，小括号中的参数，是用来接收参数用的，在函数内部作为变量使用</li><li>实参：调用函数时，小括号中的参数，是用来把数据传递到函数内部的<h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3></li><li>在程序开发中，有时候，会希望一个函数执行结束之后，告诉调用者一个结果，一边调用者对具体的结果做后续处理</li><li>返回值时函数完成工作后，最后给调用者的一个结果</li><li>在函数中 return 关键字可以返回结果</li><li>调用函数一方，可以使用变量来接受函数的返回结果</li></ul><p><strong>注意：return 之后的代码不会被执行</strong></p><h3 id="函数的嵌套调用"><a href="#函数的嵌套调用" class="headerlink" title="函数的嵌套调用"></a>函数的嵌套调用</h3><ul><li>一个函数里面又调用了另一个函数，这就是函数嵌套调用</li><li>如果函数test2中，调用了另一个函数test1<br>那么执行到调用test1函数时，会先把函数test1中的任务都执行完才会回到test2中调用test1的位置，继续执行之后的代码</li></ul><p><strong>提示：工作中针对需求的变化，应该冷静思考，不要轻易修改之前已经完成的，能够正常执行的函数</strong>！</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>08.函数基本使用</title>
      <link href="/2019/08/01/08-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/08/01/08-%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>所谓函数，就是把具有独立功能的代码块组织为一个小模块，在需要的时候调用</li><li>函数的使用包含两个步骤：</li></ul><ol><li>定义函数——封装独立的功能</li><li>调用函数——享受封装的成果</li></ol><ul><li>函数的作用，在开发程序时，使用函数可以提高编写的效率以及代码的重用<h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2>定义函数的格式如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名<span class="params">()</span>:</span></span><br><span class="line">函数封装的代码</span><br><span class="line">......</span><br></pre></td></tr></table></figure></li></ul><ol><li>def 时英文 define 的缩写</li><li>函数名称应该能够表达函数封装代码的功能，方便后续的调用</li><li>函数名称的命名应该符合标识符的命名规则<br>可以由字母，下划线和数字组成<br>不能以数字开头<br>不能与关键字重名</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>07.break和continue关键字</title>
      <link href="/2019/07/31/07-break%E5%92%8Ccontinue%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/07/31/07-break%E5%92%8Ccontinue%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><p><strong>break 和 continue是专门在循环中使用的关键字</strong></p><ul><li>break 某一条件满足时，退出循环，不再执行后续重复的代码</li><li>continue 某一条件满足时，不执行后续重复的代码</li></ul><p><strong>break 和 continue 只针对当前所在的循环有效</strong><br><strong>注意：在循环重，如果使用continue这个关键字，在使用关键字之前，需要确认循环的计数是否修改，否则可能会导致死循环。</strong></p><ul><li>\t 在控制台输出一个制表符，协助在输出文本时，垂直方向保持对齐</li><li>\n 在控制台输出一个 换行符</li><li>&quot; 输出一个 双引号 “</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>06.while循环的基本使用</title>
      <link href="/2019/07/30/06-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/07/30/06-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<ul><li>循环的作用就是让指定的代码重复执行</li><li>while循环最常用的应用场景就是让执行的代码按照指定的次数重复执行</li><li><strong>注意：</strong>while语句以及缩进部分是一个完整的代码块</li><li>注意：循环结束后，之前定义的计数器条件的数值依然是存在的</li><li>死循环：忘记在循环内部修改</li><li><strong>习惯：除非需要的特殊要求，否则循环的计数都要从0开始</strong><h3 id="循环计算"><a href="#循环计算" class="headerlink" title="循环计算"></a>循环计算</h3></li><li>在程序开发中，通常会遇到利用循环重复计算的需求，遇到这种需求，可以：</li></ul><ol><li>在while上方定义一个变量，用于存放最终计算结果</li><li>在循环体内部，每次循环都用最新的计算结果，更新之前定义的变量</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> while </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>05.随机数的处理</title>
      <link href="/2019/07/30/05-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2019/07/30/05-%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%9A%84%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<ul><li>再python中，要使用随机数，首先需要导入随机数的模块——“工具包”</li><li>import random</li><li>导入模块后，可以直接再模块后面敲一个 . 然后按tab键，会提示该模块中包含的所有函数</li><li>random.randint(a, b)  返回[a, b]之间的一个随机数，包含a 和 b</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> random </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>04.逻辑运算</title>
      <link href="/2019/07/29/04-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/"/>
      <url>/2019/07/29/04-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="04-逻辑运算"><a href="#04-逻辑运算" class="headerlink" title="04.逻辑运算"></a>04.逻辑运算</h3><ul><li><p>在程序开发中，通常在判断条件时，会需要同时判断多个条件</p></li><li><p>只有在多个条件都满足，才能够执行后续代码，这个时候需要使用到逻辑运算符</p></li><li><p>逻辑运算符可以把多个条件按照逻辑进行连接，变成更复杂的条件</p></li><li><p>python中的逻辑运算符包括：与and/ 或or/ 非not 三种</p></li><li><p>在开发中，通常希望某个条件不满足时，执行一些代码，可以使用 not</p></li><li><p>如果需要拼接复杂的逻辑计算条件，同样也有可能使用到 not</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>03.if基础</title>
      <link href="/2019/07/28/03-if%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/07/28/03-if%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="if-基础"><a href="#if-基础" class="headerlink" title="if 基础"></a>if 基础</h2><p>在python 中，if语句就是用来进行判断的，格式如下</p><pre><code>if 要判断的条件:    条件达成时，要做的事情    ....</code></pre><p><strong>注意：代码的缩进为一个tab键，或者4个空格–建议使用空格</strong></p><ul><li>在python开发中，Tab和空格不要混用</li></ul><p><strong>注意：</strong><br><strong>if语句以及缩进部分是一个完整的代码块</strong></p><h2 id="else"><a href="#else" class="headerlink" title="else"></a>else</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 要判断的条件：</span><br><span class="line">    条件成立时，要做的事情</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">条件不成立时，要做的事情</span><br></pre></td></tr></table></figure><p>注意：<br>if和else，else语句以及各自的缩进部分共同是一个完整的代码块<br>elif 和else都必须和if联合使用，而不能单独使用</p><ul><li>elif 的应用场景是：同时判断多个条件，所有条件都是平级的</li><li>在开发中，使用if 进行条件判断，如果希望在条件成立的执行语句中再增加条件判断，就可以使用if嵌套</li><li>if的嵌套的应用场景就是：在之前满足条件的前提下，再增加额外的判断</li><li>if 的嵌套的语法格式，除了了缩进之外和之前的没有区别</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> if </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02.表示符命名规则</title>
      <link href="/2019/07/28/02-%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/"/>
      <url>/2019/07/28/02-%E8%A1%A8%E7%A4%BA%E7%AC%A6%E5%91%BD%E5%90%8D%E8%A7%84%E5%88%99/</url>
      
        <content type="html"><![CDATA[<h3 id="02-变量的命名规则"><a href="#02-变量的命名规则" class="headerlink" title="02 变量的命名规则"></a>02 变量的命名规则</h3><ul><li>python中的标识符是区分大小写的</li><li>在定义变量时，为了保证代码格式， = 的左右应该保留一个空格</li><li>在python中，如果变量名需要两个或多个单词组成时，可以安装一下方式命名</li></ul><ol><li>每个单词都使用小写</li><li>单词与单词之间使用 _ 下划线连接</li><li>例如：first_name</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>01.算数运算符</title>
      <link href="/2019/07/28/01-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2019/07/28/01-%E7%AE%97%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="01-算数运算符"><a href="#01-算数运算符" class="headerlink" title="01.算数运算符"></a>01.算数运算符</h2><p>是完成基本的算数运算使用的符号，用来处理四则运算</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加</td><td>10+20=30</td></tr><tr><td>-</td><td>减</td><td></td></tr><tr><td>*</td><td>乘</td><td></td></tr><tr><td>/</td><td>除</td><td></td></tr><tr><td>//</td><td>取整除</td><td>返回除法的整数部分，9//2=4</td></tr><tr><td>%</td><td>取余数</td><td>返回除法的余数9%2=1</td></tr><tr><td>**</td><td>幂</td><td>又称次方，乘方，2**3=8</td></tr><tr><td>- 在python中*运算符还可以用于字符串，计算结果就是字符串重复指定次数的结果</td><td></td><td></td></tr><tr><td><code>“-”*50</code></td><td></td><td></td></tr><tr><td>## 02.算数运算符的优先级</td><td></td><td></td></tr><tr><td>- 和数学中的运算符优先级一致，在python中进行数学计算时，</td><td></td><td></td></tr><tr><td>- 先乘除后加减</td><td></td><td></td></tr><tr><td>- 同级运算符从左至右计算</td><td></td><td></td></tr><tr><td>- 可以使用（）调整计算的优先级</td><td></td><td></td></tr><tr><td><code>**   &gt;  * / % //  &gt;  + -</code></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>python注释与代码风格</title>
      <link href="/2019/07/28/python%E6%B3%A8%E9%87%8A%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
      <url>/2019/07/28/python%E6%B3%A8%E9%87%8A%E4%B8%8E%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h4 id="什么时候使用注释"><a href="#什么时候使用注释" class="headerlink" title="什么时候使用注释"></a>什么时候使用注释</h4><ol><li>注释不是越多越好，对于一目了然的代码，不需要添加注释</li><li>对于复杂的操作，应该在操作开始之前写上若干行注释</li><li>对于不是一目了然的代码，应该在其行尾添加注释（注释应该至少离开代码2个空格）</li><li>绝不要描述代码，只要知道代码要做什么就可以了</li></ol><h4 id="空格的使用"><a href="#空格的使用" class="headerlink" title="空格的使用"></a>空格的使用</h4><ol><li>使用空格来表示缩进而不要用制表符（Tab）。</li><li>和语法相关的每一层缩进都用4个空格来表示。</li><li>每行的字符数不要超过79个字符，如果表达式因太长而占据了多行，除了首行之外的其余各行都应该在正常的缩进宽度上再加上4个空格。</li><li>函数和类的定义，代码前后都要用两个空行进行分隔。</li><li>在同一个类中，各个方法之间应该用一个空行进行分隔。</li><li>二元运算符的左右两侧应该保留一个空格，而且只要一个空格就好。</li></ol><h4 id="标识符命名"><a href="#标识符命名" class="headerlink" title="标识符命名"></a>标识符命名</h4><ol><li>变量、函数和属性应该使用小写字母来拼写，如果有多个单词就使用下划线进行连接。</li><li>类中受保护的实例属性，应该以一个下划线开头。</li><li>类中私有的实例属性，应该以两个下划线开头。</li><li>类和异常的命名，应该每个单词首字母大写。</li><li>模块级别的常量，应该采用全大写字母，如果有多个单词就用下划线进行连接。</li><li>类的实例方法，应该把第一个参数命名为self以表示对象自身。</li><li>类的类方法，应该把第一个参数命名为cls以表示该类自身。</li></ol><h4 id="表达式和语句"><a href="#表达式和语句" class="headerlink" title="表达式和语句"></a>表达式和语句</h4><ol><li>采用内联形式的否定词，而不要把否定词放在整个表达式的前面。例如if a is not b就比if not a is b更容易让人理解。</li><li>不要用检查长度的方式来判断字符串、列表等是否为None或者没有元素，应该用if not x这样的写法来检查它。</li><li>就算if分支、for循环、except异常捕获等中只有一行代码，也不要将代码和if、for、except等写在一起，分开写才会让代码更清晰。</li><li>import语句总是放在文件开头的地方。</li><li>引入模块的时候，from math import sqrt比import math更好。</li><li>如果有多个import语句，应该将其分为三部分，从上到下分别是Python标准模块、第三方模块和自定义模块，每个部分内部应该按照模块名称的字母表顺序来排列。</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux软件安装</title>
      <link href="/2019/07/28/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
      <url>/2019/07/28/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><ul><li>4.1 通过apt安装/卸载软件</li><li>apt是 advanced packaging tool，是Linux下的一款安装包管理工具</li><li>可以在终端中方便的安装/卸载/更新软件包<br>安装软件<br><code>sudu apt install 软件包</code><br>卸载软件<br><code>sudo apt remove 软件名</code><br>更新已安装的包<br><code>sudu apt upgrade</code></li></ul><p>sudu是获取超级管理员的意思</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux其他命令</title>
      <link href="/2019/07/28/Linux%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/28/Linux%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h1><ol><li>查找文件<br>find</li><li>软链接<br>ln</li><li>打包和压缩<br>tar</li><li>软件安装<br>apt-get<h2 id="01-查找文件"><a href="#01-查找文件" class="headerlink" title="01. 查找文件"></a>01. 查找文件</h2></li></ol><ul><li>find 命令功能非常强大，通常用来在特定的目录下搜索符合条件的文件<br><code>find [路径] -name &quot;*.py&quot;             作用：查找指定路径下扩展名时 .py 的文件，包括子目录</code></li><li>如果省略路径，表示在当前文件夹下查找</li><li>之前学习的通配符，在使用find命令时同时可用</li></ul><ol><li>搜索桌面目录下，文件名包含1 的文件<br><code>find -name “*1*”</code></li><li>搜索桌面目录下，所有以.txt为扩展名的文件<br><code>find -name &quot;*.txt&quot;</code></li><li>搜索桌面目录下，以数字1开头的文件<br><code>find -name &quot;1*&quot;</code><h2 id="2-软连接"><a href="#2-软连接" class="headerlink" title="2.软连接"></a>2.软连接</h2><code>ln -s 被链接的源文件 链接文件            作用：建立文件的软链接，用通俗的方式讲类似于Windows下的快捷方式</code></li></ol><p><strong>注意：</strong></p><ul><li>1，没有 -s 选项建立的是一个硬链接文件<br>两个文件占用大小相同的硬盘空间，工作中几乎不会建立文件的硬链接</li><li>2，源文件要<strong>使用绝对路径</strong>，不能使用相对路径，这样可以方便移动链接文件后，仍然能够正常使用</li></ul><p><strong>【例子】</strong><br>1，将桌面目录下的01.py 移动到 demo/b/c 目录下<br><code>mv 01.py demo/b/c</code><br>2，在桌面目录下新建 01.py 的软链接 FirstPython<br>分别使用相对路径和绝对路径建立FirstPython<br>相对路径<code>ln -s demo/b/c/01.py 01_xiangdui</code><br>cat 显示文件内容<br>绝对路径<code>ln-s /home/chen/Desktop/demo/b/c/01.py 01_juedui</code><br>3，将FirstPython 移动到demo目录下，对比使用相对路径和绝对路径的区别</p><p>在Linux中，文件名和文件数据时分开存储的</p><h2 id="03-打包压缩"><a href="#03-打包压缩" class="headerlink" title="03.打包压缩"></a>03.打包压缩</h2><ul><li>打包压缩时日常工作中备份文件的一种方式</li><li>在不同的操作系统中，常用的打包压缩方式是不同的</li></ul><ol><li>windows中常用rar</li><li>Mac中常用zip</li><li>Linux中常用tar.gz<h3 id="3-1-打包-解包"><a href="#3-1-打包-解包" class="headerlink" title="3.1 打包/解包"></a>3.1 打包/解包</h3></li></ol><ul><li>tar是Linux中最常用的备份工具，此命令可以把一系列文件打包到一个大文件中，也可以把一个打包的大文件恢复成以系列文件</li><li>tar 的命令格式如下：<br>打包文件<br><code>tar -cvf 打包文件.rar 被打包的文件/路径...</code><br>解包文件<br><code>tar -xvf 打包文件.tar</code></li></ul><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>c</td><td>生成档案文件，创建打包文件</td></tr><tr><td>x</td><td>解开档案文件</td></tr><tr><td>v</td><td>列出归档接档的详细过程，显示进度</td></tr><tr><td>f</td><td>指定档案文件名称，f后面一定是.tar 文件，所以必须放选项最好</td></tr><tr><td><strong>注意：</strong>f 选项必须放在最后，其他选项顺序可以随意</td><td></td></tr></tbody></table><p><strong>【例子】</strong></p><ol><li>删除桌面下的所有内容<br><code>rm -r *</code></li><li>在桌面下新建3个空白文件 01.py，02.py 03.py<br><code>touch 01.py</code></li><li>将这三个文件夹打一个 py.tar的包<br><code>tar -cvf py.tar 01.py 02.py 03.py</code></li><li>新建 tar 目录，并且将 py.tar 移动到tar 目录下<br><code>mkdir tar</code><br><code>mv py.tar tar</code></li><li>解包 py.tar<br><code>tar -xvf py.tar</code><h3 id="3-2-压缩-解压缩"><a href="#3-2-压缩-解压缩" class="headerlink" title="3.2 压缩/解压缩"></a>3.2 压缩/解压缩</h3><h4 id="1）gzip"><a href="#1）gzip" class="headerlink" title="1）gzip"></a><strong>1）gzip</strong></h4></li></ol><ul><li>tar与gzip 命令结合可以实现文件打包和压缩</li></ul><ol><li>tar只负责打包文件，但不压缩</li><li>用gzip 压缩tar打包后的文件，其扩展名一般用 xxx.tar.gz</li></ol><p><em>在Linux中，最常见的压缩文件格式就是 xxx.tar.gz</em></p><ul><li>在tar 命令中有一个选项 -z 可以调用 gzip ，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：<br>压缩文件<br><code>tar -zxcf 打包文件.tar.gz 被压缩的文件/路径...</code><br>解压缩文件<br><code>tar -zxvf 打包文件.tar.gz</code><br>解压缩到指定路径<br><code>tar -zxvf 打包文件.tar.gz -C 目标路径</code><br><code>-C         含义：解压缩到指定目录，注意：要解压缩的目录必须存在</code><h4 id="2）bzip2-two"><a href="#2）bzip2-two" class="headerlink" title="2）bzip2(two)"></a><strong>2）bzip2(two)</strong></h4></li><li>tar 与bzip2 命令结合可以使用实现文件 打包和压缩 （用法和 gzip 一样）</li></ul><ol><li>tar 只负责打包文件，但不压缩</li><li>用 bzip2 压缩tar 打包后的文件，其扩展名一般用 xxx.tar.bz2</li></ol><ul><li>在tar 命令中有一个选项 -j 可以调用 bzip2 ，从而可以方便的实现压缩和解压缩的功能</li><li>命令格式如下：<br>压缩文件<br><code>tar -jcvf 打包文件.tar.bz2 被压缩的文件/路径/...</code><br>解压缩文件<br><code>tar -jxvf 打包文件.tar.bz2</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统信息相关命令</title>
      <link href="/2019/07/28/Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/28/Linux%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="系统信息相关命令"><a href="#系统信息相关命令" class="headerlink" title="系统信息相关命令"></a>系统信息相关命令</h1><h2 id="01，时间和日期"><a href="#01，时间和日期" class="headerlink" title="01，时间和日期"></a>01，时间和日期</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>date</td><td>查看系统时间</td></tr><tr><td>02</td><td>cal</td><td>查看系统日历</td></tr></tbody></table><h2 id="02，磁盘信息"><a href="#02，磁盘信息" class="headerlink" title="02，磁盘信息"></a>02，磁盘信息</h2><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>df -h</td><td>disk free 显示磁盘剩余空间</td></tr><tr><td>02</td><td>du -h [目录名]</td><td>disk usage 显示目录下的文件大小</td></tr><tr><td><strong>选项说明</strong></td><td></td><td></td></tr><tr><td><code>-h   以人性化的方式显示文件大小</code></td><td></td><td></td></tr><tr><td>## 03，进程信息</td><td></td><td></td></tr><tr><td>- 所谓进程，通俗地说就是当前正在执行的一个程序</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>序号</th><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ps aux</td><td>process status 查看进程的详细状况</td></tr><tr><td>02</td><td>top</td><td>动态显示运行中的程序并且排序</td></tr><tr><td>03</td><td>kill [-9] 进程代号</td><td>终止指定代号的进程，-9表示强行终止</td></tr><tr><td>ps <strong>默认只会显示当前用户通过终端启动的应用程序</strong></td><td></td><td></td></tr><tr><td>- ps 选项功能说明</td><td></td><td></td></tr></tbody></table><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>a</td><td>显示终端上的所有程序，包括其他用户的进程</td></tr><tr><td>u</td><td>显示进程的详细状态</td></tr><tr><td>x</td><td>显示没有控制终端的进程</td></tr><tr><td><strong>提示：使用kill 命令时，最好只终止由当前用户开启的进程，而不要终止root身份开启的进程，否则可能导致系统崩溃</strong></td><td></td></tr><tr><td>- 要退出top 可以直接输入 q</td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-08-scp作用以及命令格式</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-08-scp%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-08-scp%E4%BD%9C%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="3-2-scp（掌握）"><a href="#3-2-scp（掌握）" class="headerlink" title="3.2 scp（掌握）"></a>3.2 scp（掌握）</h2><ul><li>scp就是 secure copy，是一个在Linux下用来进行远程拷贝文件的命令</li><li>它的格式地址与ssh基本相同，需要注意的是，在指定端口时，用的是大写的 -P 而不是小写的</li></ul><ol><li>把本地目录下的01.py 文件 复制到远程 家 目录下的 Desktop/01.py </li></ol><p><strong>注意：</strong>“：”后面的路径如果不是绝对路径，则以用户的家目录为参考路径<br><code>scp -P port 01.py user@remote:Decktop/01.py</code></p><ol start="2"><li>把远程目录 家目录下的 Desktop/01.py 文件 复制到 本地目录下的01.py<br><code>scp -P port user@remote:Dedktop/01.py 01.py .</code><br>加上 -r 选项可以传送文件夹</li><li>把当前目录下的 demo 文件夹复制到远程家目录下单 Desktop<br><code>scp -r demo user@remote:Desktop</code></li><li>把远程家目录下的Desktop 复制到 当前目录下的 demo 文件夹<br><code>scp -r user@remote:Desktop demo</code></li></ol><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>若给出的源文件是目录文件，则scp将递归复制该目录下的所有子目录和文件，目标文件必须为一个目录名</td></tr><tr><td>-P</td><td>若远程SSH服务器的端口不是22，需要使用大写字母 -P 选项指定端口</td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>scp 这个终端命令只能在Linux 或者UNIX系统下使用</li><li>如果在Windows系统中，可以安装PuTTY，使用pscp命令工具行或者安装FileZilla 使用FTP进行文件传输（因是ftp，故端口号设置为21）</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-07-ssh命令格式介绍和演练目标确定</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-07-ssh%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%BC%94%E7%BB%83%E7%9B%AE%E6%A0%87%E7%A1%AE%E5%AE%9A/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-07-ssh%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F%E4%BB%8B%E7%BB%8D%E5%92%8C%E6%BC%94%E7%BB%83%E7%9B%AE%E6%A0%87%E7%A1%AE%E5%AE%9A/</url>
      
        <content type="html"><![CDATA[<h3 id="2，SSH客户端的简单使用"><a href="#2，SSH客户端的简单使用" class="headerlink" title="2，SSH客户端的简单使用"></a>2，SSH客户端的简单使用</h3><p><code>ssh [-p port] user@remote</code></p><ul><li>user 是在远程机器上的用户名，如果不指定的话，为当前用户</li><li>remote 是远程机器的地址，可以是IP/域名， 或者是后面会提到的别名</li><li>port是SSH　Server监听的端口，如果不指定，就为默认值２２</li></ul><p><strong>提示：</strong></p><ul><li>使用 exit 退出当前用户的登陆</li></ul><p><strong>注意：</strong></p><ul><li>ssh这个终端命令只能在 Linux 或者UNIX系统下使用</li><li>如果在windows系统中，可以安装 PuTTY 或者 XShell 客户端软件即可</li></ul><p><strong>提示：</strong></p><ul><li>在工作中，SSH服务器的端口号很有可能不是22，如果遇到这种情况就要使用 <code>-p</code> 选项；指定正确的端口号，否则无法正常连接到服务器</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-06-域名和端口的概念</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-06-%E5%9F%9F%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-06-%E5%9F%9F%E5%90%8D%E5%92%8C%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="1-域名和端口"><a href="#1-域名和端口" class="headerlink" title="1. 域名和端口"></a>1. 域名和端口</h3><p><strong>域名</strong></p><ul><li>由一串用点分隔的名字组成，例如：<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></li><li>是IP地址的别名，方便用户记忆</li></ul><p><strong>端口号</strong></p><ul><li>IP地址：通过IP地址找到网络上的计算机</li><li>端口号：通过端口号可以找到计算机上的应用程序</li></ul><ol><li>SSH服务器的默认端口号是22，如果是默认端口号，在连接的时候，可以省略</li></ol><ul><li>常见的服务端口号列表</li></ul><table><thead><tr><th>序号</th><th>服务</th><th>端口号</th></tr></thead><tbody><tr><td>01</td><td>SSH服务器</td><td>22</td></tr><tr><td>02</td><td>Web服务器</td><td>80</td></tr><tr><td>03</td><td>HTTPS</td><td>443</td></tr><tr><td>04</td><td>FTP服务器</td><td>21</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-04-SSH工作方式简介</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-05-SSH%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-05-SSH%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="03-远程登陆和复制文件"><a href="#03-远程登陆和复制文件" class="headerlink" title="03.远程登陆和复制文件"></a>03.远程登陆和复制文件</h2><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ssh用户名@ip</td><td>secure shell</td><td>关机/从新启动</td></tr><tr><td>02</td><td>scp用户名@ip:文件名或路径 用户名@ip:文件名或路径</td><td>secure copy</td><td>远程复制文件</td></tr></tbody></table><h2 id="3-1-ssh基础（重点）"><a href="#3-1-ssh基础（重点）" class="headerlink" title="3.1 ssh基础（重点）"></a>3.1 ssh基础（重点）</h2><ul><li>在Linux中SSH是非常常用的工具，通过SSH客户端我们可以连接到运行了SSH服务器的远程机器上</li></ul><ol><li>数据传输是加密的，可以防止信息泄露</li><li>数据时输是压缩的，可以提高传输速度</li></ol><ul><li>SSH客户端是一种使用 Secure Shell（SSH）协议连接到远程计算机的软件程序</li><li>SSH是目前较可靠，专为远程登陆会话和其他网络服务提供安全性的协议</li></ul><ol><li>利用SSH协议可以有效防止远程管理过程中的信息泄露</li><li>通过SSH协议可以对所有数据传输进行加密，也能够防止DNS欺骗和IP欺骗</li></ol><ul><li>SSH的另一项优点是可以经过压缩的，所以可以加快传输的速度</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-05-ping测试网络连接</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-04-ping%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-04-ping%E6%B5%8B%E8%AF%95%E7%BD%91%E7%BB%9C%E8%BF%9E%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="2-3-ping"><a href="#2-3-ping" class="headerlink" title="2.3 ping"></a>2.3 ping</h2><p>检测到目标主机是否连接正常<br><code>ping IP地址</code><br>检测本地网卡工作正常<br><code>ping 127.0.0.1</code></p><ul><li>ping 一般用于检测当前计算机到目标计算机之间的网络是否通畅，数值越大，速度越慢</li><li>ping一下计算机x，看他是否开着，原理：网络上的机器都有唯一确定的IP地址，我们给目标IP地址发送一个数据包，对方就要返回一个数据包，根据返回的数据包以及时间，我们可以确定目标主机的存在</li></ul><p><strong>提示：</strong>在Linux中，想要终止一个终端程序的执行，绝大多数都可以用CTRL+ C</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-03-ifconfig查询网卡信息</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-03-ifconfig%E6%9F%A5%E8%AF%A2%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-03-ifconfig%E6%9F%A5%E8%AF%A2%E7%BD%91%E5%8D%A1%E4%BF%A1%E6%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="2-2-ifconfig"><a href="#2-2-ifconfig" class="headerlink" title="2.2 ifconfig"></a>2.2 ifconfig</h2><ul><li>ifconfig 可以查看/配置计算机当前网卡配置信息</li></ul><ol><li>查看网卡配置信息<br><code>ifconfig</code></li><li>查看网卡对应的IP地址<br><code>ifconfig | grep inet</code></li></ol><p><strong>提示：</strong>一台计算机中有可能会有一个物理网卡和多个虚拟网卡，在Linux中物理网卡的名字通常以ensXX表示</p><ul><li>127.0.0.1 被称为本地回环/环回地址， 一般用来测试本机网卡是否正常</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux远程管理命令-02-网卡和IP地址的概念</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-02-%E7%BD%91%E5%8D%A1%E5%92%8CIP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-02-%E7%BD%91%E5%8D%A1%E5%92%8CIP%E5%9C%B0%E5%9D%80%E7%9A%84%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h1 id="02，查看或配置网卡信息"><a href="#02，查看或配置网卡信息" class="headerlink" title="02，查看或配置网卡信息"></a>02，查看或配置网卡信息</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>ifconfig</td><td>confi</td><td>查看/配置</td></tr><tr><td>02</td><td>ping ip地中</td><td>ping</td><td>检测目标ip地址的连接是否正常</td></tr><tr><td>## 2.1 网卡和IP地址</td><td></td><td></td><td></td></tr><tr><td><strong>网卡</strong></td><td></td><td></td><td></td></tr><tr><td>- 网卡是一个专门负责网络通讯的硬件设备</td><td></td><td></td><td></td></tr><tr><td>- IP地址是设置在网卡上的地址信息</td><td></td><td></td><td></td></tr><tr><td>我们可以把电脑比作电话，网卡相当于SIM卡，IP地址相当于电话号码</td><td></td><td></td><td></td></tr><tr><td><strong>IP地址</strong></td><td></td><td></td><td></td></tr><tr><td>- 每台联网的电脑上都有IP地址，是保证电脑之间正常通讯的重要设置</td><td></td><td></td><td></td></tr><tr><td><strong>注意：</strong>每台电脑的IP地址不能相同，否则会出现IP地址冲突，并且没有办法正常通讯</td><td></td><td></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 远程管理命令-01-关机和重启</title>
      <link href="/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-01-%E5%85%B3%E6%9C%BA%E5%92%8C%E9%87%8D%E5%90%AF/"/>
      <url>/2019/07/27/Linux%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4-01-%E5%85%B3%E6%9C%BA%E5%92%8C%E9%87%8D%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="关机-重启"><a href="#关机-重启" class="headerlink" title="关机/重启"></a>关机/重启</h1><table><thead><tr><th>序号</th><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>01</td><td>shutdown 选项 时间</td><td>shutdown</td><td>关机/重新启动</td></tr></tbody></table><p>1.1 shutdown</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-r</td><td>重新启动</td></tr><tr><td><strong>提示：</strong></td><td></td></tr><tr><td>- 不指定选项和参数，默认表示一分钟之后关闭电脑</td><td></td></tr><tr><td>- 远程维护服务器时，最好不要关闭系统，而应该重启系统</td><td></td></tr><tr><td><strong>常用命令示例</strong></td><td></td></tr><tr><td>1. 重新启动系统，其中 now 表示现在</td><td></td></tr><tr><td><code>shutdown now</code></td><td></td></tr><tr><td>2. 立刻关机，其中now表示现在</td><td></td></tr><tr><td><code>shutdown now</code></td><td></td></tr><tr><td>3. 系统在今天的 20：35 会关机</td><td></td></tr><tr><td><code>shutdown 20：35</code></td><td></td></tr><tr><td>4. 取消之前指定的关机计划</td><td></td></tr><tr><td><code>shutdown -c</code></td><td></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux常用命令</title>
      <link href="/2019/07/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/07/26/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><p><strong>Linux是区分大小写的</strong></p><table><thead><tr><th>命令</th><th>对应英文</th><th>作用</th></tr></thead><tbody><tr><td>ls</td><td>list</td><td>查看当前文件夹下的内容</td></tr><tr><td>cd[目录名]</td><td>change directory</td><td>切换文件夹（cd xxx）</td></tr><tr><td>pwd</td><td>print work directory</td><td>查看当前所在文件夹</td></tr><tr><td>touch[文件名]</td><td>touch</td><td>如果文件不存在，新建文件</td></tr><tr><td>mkdir[目录名]</td><td>make directory</td><td>创建目录</td></tr><tr><td>rm[文件名]</td><td>remove</td><td>删除指定的文件名</td></tr><tr><td>clear</td><td>clear</td><td>清屏</td></tr></tbody></table><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><ul><li>ctrl + shift + =    放大终端窗口的字体显示</li><li>ctrl + -    缩小终端窗口的字体显示</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux终端命令格式</title>
      <link href="/2019/07/26/Linux%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/"/>
      <url>/2019/07/26/Linux%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%A0%BC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux终端命令格式"><a href="#Linux终端命令格式" class="headerlink" title="Linux终端命令格式"></a>Linux终端命令格式</h2><h3 id="1，终端命令格式"><a href="#1，终端命令格式" class="headerlink" title="1，终端命令格式"></a>1，终端命令格式</h3><p>command [-options] [parameter]<br><strong>说明：</strong></p><ul><li>command：命令名，相应功能的英文单词或单词的缩写</li><li>[-options]：选项，可用来对命令进行控制，也可以省略</li><li>parameter：传给命令的参数，可以是零个，一个，或者多个</li></ul><h3 id="2，查阅命令帮助信息"><a href="#2，查阅命令帮助信息" class="headerlink" title="2，查阅命令帮助信息"></a>2，查阅命令帮助信息</h3><p>–help<br><code>command --help</code><br><strong>说明：</strong></p><ul><li>显示command命令的帮助信息</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql修改表(2)</title>
      <link href="/2019/07/26/MySql%E4%BF%AE%E6%94%B9%E8%A1%A8/"/>
      <url>/2019/07/26/MySql%E4%BF%AE%E6%94%B9%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql修改表"><a href="#MySql修改表" class="headerlink" title="MySql修改表"></a>MySql修改表</h2><p>对表的修改失败要用rollback（）方法进行回滚<br>execute()中要用元组，mysql传递一个参数的时候，可以不用逗号(103)或者(103,)都可以，在sqlite中逗号不能少<br>  <strong>【实例】</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改有rollback</span></span><br><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">    <span class="comment"># 创建与数据库的连接</span></span><br><span class="line">    con = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, password=<span class="string">'root'</span>, database=<span class="string">'testmysql'</span>, port=3306)</span><br><span class="line">    <span class="comment"># 创建游标对象cursor</span></span><br><span class="line">    cursor = con.cursor()</span><br><span class="line">    <span class="comment"># 写修改的sql</span></span><br><span class="line">    sql = <span class="string">'update student set sname = %s where sno = %s'</span></span><br><span class="line">    cursor.execute(sql, (<span class="string">'哈哈'</span>, 100))     <span class="comment"># 要用元组，</span></span><br><span class="line">    con.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'修改成功'</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'修改失败'</span>)</span><br><span class="line">    con.rollback()</span><br><span class="line"></span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭数据库连接</span></span><br><span class="line">    con.close()</span><br><span class="line">    cursor.close()</span><br></pre></td></tr></table></figure><h2 id="MySql删除表"><a href="#MySql删除表" class="headerlink" title="MySql删除表"></a>MySql删除表</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># 修改有rollback</span><br><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">    # 创建与数据库的连接</span><br><span class="line">    con = pymysql.connect(host=&apos;localhost&apos;, user=&apos;root&apos;, password=&apos;root&apos;, database=&apos;testmysql&apos;, port=3306)</span><br><span class="line">    # 创建游标对象cursor</span><br><span class="line">    cursor = con.cursor()</span><br><span class="line">    # 写修改的sql</span><br><span class="line">    sql = &apos;update student set sname = %s where sno = %s&apos;</span><br><span class="line">    cursor.execute(sql, (&apos;哈哈&apos;, 100))     # 要用元组，</span><br><span class="line">    con.commit（）</span><br><span class="line">    print(&apos;修改成功&apos;)</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(e)</span><br><span class="line">    print(&apos;修改失败&apos;)</span><br><span class="line">    con.rollback()</span><br><span class="line"></span><br><span class="line">finally:</span><br><span class="line">    # 关闭数据库连接</span><br><span class="line">    con.close()</span><br><span class="line">    cursor.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql查询数据(4)</title>
      <link href="/2019/07/26/Mysql%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/07/26/Mysql%E6%9F%A5%E8%AF%A2%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>  <strong>【实例】</strong><br>  获取要用元组的下标索引，与插入不同的是要处理结果集</p><pre><code class="bash">import pymysql<span class="comment"># 创建连接</span>con = pymysql.connect(host=<span class="string">'localhost'</span>, password=<span class="string">'root'</span>, user=<span class="string">'root'</span>, database=<span class="string">'testmysql'</span>, port=3306)<span class="comment"># 创建事务</span>cur = con.cursor()<span class="comment"># 编写查询的sql</span>sql = <span class="string">'select * from student'</span><span class="comment"># 执行sql</span>try:    cur.execute(sql)    <span class="comment"># 处理结果集</span>    stu = cur.fetchone()    <span class="built_in">print</span>(stu)    students = cur.fetchall()    <span class="keyword">for</span> student <span class="keyword">in</span> students:    <span class="comment"># 获取要用下标，索引从0开始</span>        sno = student[0]        sname = student[1]        sex = student[2]        age = student[3]        score = student[4]        <span class="built_in">print</span>(<span class="string">'sno:'</span>, sno, <span class="string">'sname:'</span>, sname, <span class="string">'age:'</span>, age, <span class="string">'sex:'</span>, sex, <span class="string">'age:'</span>, age,  <span class="string">'score:'</span>, score)except Exception as e:    <span class="built_in">print</span>(e)    <span class="built_in">print</span>(<span class="string">'查询失败'</span>)finally:    cur.close()    con.close()</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql插入数据(3)</title>
      <link href="/2019/07/26/MySql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/07/26/MySql%E6%8F%92%E5%85%A5%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>  <strong>【实例】</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line"><span class="comment"># 创建与数据的连接</span></span><br><span class="line">con = pymysql.connect(host=<span class="string">'localhost'</span>, password=<span class="string">'root'</span>, user=<span class="string">'root'</span>, database=<span class="string">'testmysql'</span>, port=3306)</span><br><span class="line"><span class="comment"># 创建游标对象</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"><span class="comment"># 写插入数据库的sql</span></span><br><span class="line">sql = <span class="string">'insert into student(sno, sname, sex, age, score) values(%s, %s, %s, %s, %s)'</span>      <span class="comment"># s要小写，不然会报unsupported format character 'S' (0x53) at index 72</span></span><br><span class="line">try:</span><br><span class="line">    <span class="comment"># 执行sql插入一条数据</span></span><br><span class="line">    <span class="comment"># cur.execute(sql, (1100, '张三', '男', 33, 33.3))</span></span><br><span class="line">    <span class="comment"># 插入多条数据</span></span><br><span class="line">    args = [(102, <span class="string">'张2'</span>, <span class="string">'男'</span>, 33, 33.3), (103, <span class="string">'张4'</span>, <span class="string">'男'</span>, 33, 33.3), (104, <span class="string">'张5'</span>, <span class="string">'男'</span>, 33, 33.3)]     <span class="comment"># 插入多条数据要用executemany</span></span><br><span class="line">    cur.executemany(sql, args)</span><br><span class="line">    con.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'插入成功'</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'插入失败'</span>)</span><br><span class="line">finally:</span><br><span class="line">    con.close()</span><br><span class="line">    cur.close()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySql创建表(1)</title>
      <link href="/2019/07/26/MySql%E5%88%9B%E5%BB%BA%E8%A1%A8/"/>
      <url>/2019/07/26/MySql%E5%88%9B%E5%BB%BA%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="MySql创建表"><a href="#MySql创建表" class="headerlink" title="MySql创建表"></a>MySql创建表</h2><p>首先要在navicat中连接数据库，创建一个testtmysql的数据库<br>  <strong>【实例】</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">try:</span><br><span class="line">    <span class="comment"># 创建与数据库的连接</span></span><br><span class="line">    db = pymysql.connect(host=<span class="string">'localhost'</span>, user=<span class="string">'root'</span>, password=<span class="string">'root'</span>, database=<span class="string">'testmysql'</span>, port=3306)</span><br><span class="line">    <span class="comment"># 创建游标对象cursor</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 使用execute()方法执行sql，如果表存在则删除</span></span><br><span class="line">    cursor.execute(<span class="string">'drop table if EXISTS student'</span>)</span><br><span class="line">    <span class="comment"># 创建表的sql</span></span><br><span class="line">    sql = <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">        create table student(</span></span><br><span class="line"><span class="string">        sno int(8) primary key auto_increment,</span></span><br><span class="line"><span class="string">        sname varchar(30) not null,</span></span><br><span class="line"><span class="string">        sex varchar(5) ,</span></span><br><span class="line"><span class="string">        age int(2),</span></span><br><span class="line"><span class="string">        score float(3,1)</span></span><br><span class="line"><span class="string">        )</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建成功"</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'创建表失败'</span>)</span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭数据库连接</span></span><br><span class="line">    db.close()</span><br><span class="line">    cursor.close()</span><br></pre></td></tr></table></figure><p>![]<br>(<a href="https://github.com/gxnucgb/python/blob/master/MYSq%E5%88%9B%E5%BB%BA%E8%A1%A8.png">https://github.com/gxnucgb/python/blob/master/MYSq%E5%88%9B%E5%BB%BA%E8%A1%A8.png</a>)</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlite3学习</title>
      <link href="/2019/07/25/sqlite3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/25/sqlite3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="1，操作流程"><a href="#1，操作流程" class="headerlink" title="1，操作流程"></a>1，操作流程</h2><p>（1）先在文件夹创建出一个.db文件<br>  （2）导入相关库或模块（SQLite3)<br>  （3）使用connect()连接数据库并获取数据库对象。他提供了以下方法：<br>  .cursor() 方法来创建一个游标对象<br>  .commit() 方法来处理事务提交<br>  .rollback() 方法来处理事务回滚<br>  .close() 方法来关闭一个数据库连接<br>  （4）使用con.cursor() 获取游标对象<br>  （5）使用游标对象的方法execute()、executemany()、fetchall() 等来操作数据库，实现数据库插入、修改和删除操作，并查询获取显示相关的记录。在Python程序中，连接函数sqlite3.connert()有如下两个常用的参数：<br>database:表示要访问的数据库名。<br>timeout():表示访问数据的超时设定。<br>  （6）使用close()关闭游标对象和数据库连接。数据库操作完成之后，必须及时调用其close()方法关闭数据库连接，这样做的目的是减轻数据服务器的压力。<br>  （7）他的的不同有sql语句，执行的时候的参数</p><h2 id="2，使用SQLite3创建表"><a href="#2，使用SQLite3创建表" class="headerlink" title="2，使用SQLite3创建表"></a>2，使用SQLite3创建表</h2><p>使用sqlite3模块的connect方法来创建/打开数据库，需要指定数据库路径，不存在则创建一个新的数据库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">con = sqlite3.connect(<span class="string">'e:/sqlitedb/first.db'</span>)   <span class="comment">#路径的那个斜杠要反过来写，文件不存在则创建文件</span></span><br></pre></td></tr></table></figure><p><strong><em>【实例】</em></strong>使用sqlite3创建表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sqlite3模块</span></span><br><span class="line">import sqlite3</span><br><span class="line"><span class="comment"># 硬盘上创建连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">'E:/python/tank/sqlite3.db'</span>)</span><br><span class="line"><span class="comment"># 获取cursor(游标)对象</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line">sql = <span class="string">'create table Student (id int(10) primary key, \</span></span><br><span class="line"><span class="string">                                name char(20) not null \</span></span><br><span class="line"><span class="string">                              )'</span></span><br><span class="line">try:</span><br><span class="line">    <span class="comment"># 执行语句</span></span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建成功"</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"创建失败"</span>)</span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭游标</span></span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    con.close()</span><br></pre></td></tr></table></figure><h2 id="2，使用SQLite3插入数据"><a href="#2，使用SQLite3插入数据" class="headerlink" title="2，使用SQLite3插入数据"></a>2，使用SQLite3插入数据</h2><p>调用游标对象的execute执行插入的sql，使用executemany()执行多条sql语句，使用executmany()比循环使用execu()执行多条sql语句效率高<br><strong><em>【实例】</em></strong>使用sqlite3在表中插入数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sqlite3模块</span></span><br><span class="line">import sqlite3</span><br><span class="line"><span class="comment"># 在硬盘上创建连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">'E:/python/tank/sqlite3.db'</span>)</span><br><span class="line"><span class="comment"># 获取cursor对象</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"><span class="comment"># 执行sql创建表</span></span><br><span class="line">sql = <span class="string">'insert into Student(id, name) values(?, ?)'</span>      <span class="comment"># 问号是用来占位的</span></span><br><span class="line">try:</span><br><span class="line">    cur.execute(sql, (112, <span class="string">'小潘'</span>))       <span class="comment"># 用元组来写数据</span></span><br><span class="line">    <span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string">    插入多条数据</span></span><br><span class="line"><span class="string">    cur.executemany(sql, [(100, "小陈"), (101, "小李")])    #执行多条插入的时候，要用列表＋元组来存，插入重复数据会报错</span></span><br><span class="line"><span class="string">    '</span><span class="string">''</span></span><br><span class="line">    <span class="comment"># 提交事务</span></span><br><span class="line">    con.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'插入成功'</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"插入失败"</span>)</span><br><span class="line">    con.rollback()</span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭游标</span></span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    con.close()</span><br></pre></td></tr></table></figure><h2 id="2，使用SQLite3查询数据"><a href="#2，使用SQLite3查询数据" class="headerlink" title="2，使用SQLite3查询数据"></a>2，使用SQLite3查询数据</h2><p><strong><em>【实例】</em></strong>使用sqlite3查询表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sqlite3模块</span></span><br><span class="line">import sqlite3</span><br><span class="line"><span class="comment"># 硬盘上创建连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">'E:/python/tank/sqlite3.db'</span>)</span><br><span class="line"><span class="comment"># 获取cursor对象</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line">sql = <span class="string">'select * from Student'</span></span><br><span class="line">try:</span><br><span class="line">    cur.execute(sql)</span><br><span class="line">    <span class="comment"># 与插入不同的是要获取结果集</span></span><br><span class="line">    <span class="comment"># 获取一条结果</span></span><br><span class="line">    stu1 = cur.fetchone()</span><br><span class="line">    <span class="built_in">print</span>(stu1)</span><br><span class="line">    stu_all = cur.fetchall()</span><br><span class="line">    <span class="comment"># print(stu_all)</span></span><br><span class="line">    <span class="keyword">for</span> stu <span class="keyword">in</span> stu_all:</span><br><span class="line">        <span class="built_in">print</span>(stu)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'查询所有数据失败'</span>)</span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭游标</span></span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    con.close()</span><br></pre></td></tr></table></figure><h2 id="3，使用SQLite3修改数据"><a href="#3，使用SQLite3修改数据" class="headerlink" title="3，使用SQLite3修改数据"></a>3，使用SQLite3修改数据</h2><p><strong><em>【实例】</em></strong>使用sqlite3修改表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sqlite3模块</span></span><br><span class="line">import sqlite3</span><br><span class="line"><span class="comment"># 硬盘上创建连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">'E:/python/tank/sqlite3.db'</span>)</span><br><span class="line"><span class="comment"># 获取cursor对象</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"><span class="comment"># 写修改语句</span></span><br><span class="line">sql = <span class="string">'update Student set name=? where id = ?'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行sql</span></span><br><span class="line">try:</span><br><span class="line">     <span class="comment"># 执行修改</span></span><br><span class="line">     cur.execute(sql, (<span class="string">"hahah"</span>, 112))</span><br><span class="line">     <span class="comment"># 提交事务</span></span><br><span class="line">     con.commit()</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"修改失败"</span>)</span><br><span class="line">    con.rollback()</span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭游标</span></span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    con.close()</span><br></pre></td></tr></table></figure><h2 id="3，使用SQLite3删除数据"><a href="#3，使用SQLite3删除数据" class="headerlink" title="3，使用SQLite3删除数据"></a>3，使用SQLite3删除数据</h2><p><strong><em>【实例】</em></strong>使用sqlite3删除表中数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入sqlite3模块</span></span><br><span class="line">import sqlite3</span><br><span class="line"><span class="comment"># 硬盘上创建连接</span></span><br><span class="line">con = sqlite3.connect(<span class="string">'E:/python/tank/sqlite3.db'</span>)</span><br><span class="line"><span class="comment"># 获取cursor对象</span></span><br><span class="line">cur = con.cursor()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写删除语句</span></span><br><span class="line">sqldel = <span class="string">'delete from Student where id =?'</span></span><br><span class="line"><span class="comment"># 执行sql</span></span><br><span class="line">try:</span><br><span class="line">    <span class="comment"># 执行删除</span></span><br><span class="line">    cur.execute(sqldel, (112,))       <span class="comment"># 必须是元组类型，所以（112, )逗号不能少</span></span><br><span class="line">    con.commit()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'删除成功'</span>)</span><br><span class="line">except Exception as e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"修改失败"</span>)</span><br><span class="line">    con.rollback()</span><br><span class="line">finally:</span><br><span class="line">    <span class="comment"># 关闭游标</span></span><br><span class="line">    cur.close()</span><br><span class="line">    <span class="comment"># 关闭连接</span></span><br><span class="line">    con.close()</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在上面的实例中，首先定义查询在上述实例代码中，首先定义查询所有数据、插入数据、修改数据、删除数据的方法。然后，定义主方法中依次建立连接，获取连接的cursor，通过cursor的execute()等方法来执行SQL语句，调用插入记录、更加记录、删除记录的方法。<br>  特别注意：execute参数中的是sql语句和元组！！</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sqlite3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/07/24/hello-world/"/>
      <url>/2019/07/24/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>坦克项目小学习1</title>
      <link href="/2019/07/24/%E5%9D%A6%E5%85%8B%E9%A1%B9%E7%9B%AE%E5%B0%8F%E5%AD%A6%E4%B9%A01/"/>
      <url>/2019/07/24/%E5%9D%A6%E5%85%8B%E9%A1%B9%E7%9B%AE%E5%B0%8F%E5%AD%A6%E4%B9%A01/</url>
      
        <content type="html"><![CDATA[<h4 id="坦克小项目学习"><a href="#坦克小项目学习" class="headerlink" title="坦克小项目学习"></a>坦克小项目学习</h4><h5 id="1，分析。"><a href="#1，分析。" class="headerlink" title="1，分析。"></a>1，分析。</h5><p>在写一个项目代码之前，应该要对项目进行分析，分析他可以分为多少个模块，进而得到他应该有多少个类，分析出他的主类是什么。  </p><h5 id="2，再分析。"><a href="#2，再分析。" class="headerlink" title="2，再分析。"></a>2，再分析。</h5><p>  在得到有多少个类之后，对类进行分析，分析他具有什么方法，具有什么属性（相似的类可以使用继承。  </p><h5 id="3，建框架。"><a href="#3，建框架。" class="headerlink" title="3，建框架。"></a>3，建框架。</h5><p>在pycharm创建的项目中，先写出这些类还有方法，构建出一个项目框架。  </p><h5 id="4，写主窗口。"><a href="#4，写主窗口。" class="headerlink" title="4，写主窗口。"></a>4，写主窗口。</h5><p>写出显示主窗口，可到官网<a href="http://www.pygame.org学习查看文档。" target="_blank" rel="noopener">www.pygame.org学习查看文档。</a>   </p><h6 id="1，导入pygame"><a href="#1，导入pygame" class="headerlink" title="1，导入pygame"></a>1，导入pygame</h6><h6 id="2，显示一个窗口先要调用init方法初始化一个窗口"><a href="#2，显示一个窗口先要调用init方法初始化一个窗口" class="headerlink" title="2，显示一个窗口先要调用init方法初始化一个窗口"></a>2，显示一个窗口先要调用init方法初始化一个窗口</h6><p>  set_mode(resolution = (0, 0), flags = 0, depth = 0)   -&gt;suface，创建一个显示surface，传入的参数是resolution参数是一对表示宽度和高度的数字用（元组），flags参数是其他选项的集合，depth表示用于颜色的位数。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
